function Link(t, e) { this.nodeA = t, this.nodeB = e, this.text = "", this.lineAngleAdjust = 0, this.parallelPart = .5, this.perpendicularPart = 0 } function Node(t, e) { this.x = t, this.y = e, this.mouseOffsetX = 0, this.mouseOffsetY = 0, this.isAcceptState = !1, this.text = "", this.textOnly = !1 } function SelfLink(t, e) { this.node = t, this.anchorAngle = 0, this.mouseOffsetAngle = 0, this.text = "", e && this.setAnchorPoint(e.x, e.y) } function StartLink(t, e) { this.node = t, this.deltaX = 0, this.deltaY = 0, this.text = "", e && this.setAnchorPoint(e.x, e.y) } function TemporaryLink(t, e) { this.from = t, this.to = e } function ExportAsLaTeX(t) { this.bounds = t, this._points = [], this._texData = "", this._scale = .1, this.toLaTeX = function () { return "\\documentclass[12pt]{article}\n\\usepackage{tikz}\n\n\\begin{document}\n\n\\begin{center}\n\\begin{tikzpicture}[scale=0.2]\n\\tikzstyle{every node}+=[inner sep=0pt]\n" + this._texData + "\\end{tikzpicture}\n\\end{center}\n\n\\end{document}\n" }, this.beginPath = function () { this._points = [] }, this.arc = function (t, e, n, s, i, a) { if (t -= this.bounds[0], e -= this.bounds[1], t *= this._scale, e *= this._scale, n *= this._scale, i - s == 2 * Math.PI) this._texData += "\\draw [" + this.strokeStyle + "] (" + fixed(t, 3) + "," + fixed(-e, 3) + ") circle (" + fixed(n, 3) + ");\n"; else { if (a) { var o = s; s = i, i = o } i < s && (i += 2 * Math.PI), Math.min(s, i) < -2 * Math.PI ? (s += 2 * Math.PI, i += 2 * Math.PI) : Math.max(s, i) > 2 * Math.PI && (s -= 2 * Math.PI, i -= 2 * Math.PI), s = -s, i = -i, this._texData += "\\draw [" + this.strokeStyle + "] (" + fixed(t + n * Math.cos(s), 3) + "," + fixed(-e + n * Math.sin(s), 3) + ") arc (" + fixed(180 * s / Math.PI, 5) + ":" + fixed(180 * i / Math.PI, 5) + ":" + fixed(n, 3) + ");\n" } }, this.moveTo = this.lineTo = function (t, e) { t -= this.bounds[0], e -= this.bounds[1], t *= this._scale, e *= this._scale, this._points.push({ x: t, y: e }) }, this.stroke = function () { if (0 != this._points.length) { this._texData += "\\draw [" + this.strokeStyle + "]"; for (var t = 0; t < this._points.length; t++) { var e = this._points[t]; this._texData += (t > 0 ? " --" : "") + " (" + fixed(e.x, 2) + "," + fixed(-e.y, 2) + ")" } this._texData += ";\n" } }, this.fill = function () { if (0 != this._points.length) { this._texData += "\\fill [" + this.strokeStyle + "]"; for (var t = 0; t < this._points.length; t++) { var e = this._points[t]; this._texData += (t > 0 ? " --" : "") + " (" + fixed(e.x, 2) + "," + fixed(-e.y, 2) + ")" } this._texData += ";\n" } }, this.measureText = function (t) { var e = canvas.getContext("2d"); return e.font = '20px "Times New Romain", serif', e.measureText(t) }, this.advancedFillText = function (t, e, n, s, i) { if (n -= this.bounds[0], s -= this.bounds[1], t.replace(" ", "").length > 0) { var a = ""; if (null != i) { var o = this.measureText(t).width, r = Math.cos(i), c = Math.sin(i); Math.abs(r) > Math.abs(c) ? r > 0 ? (a = "[right] ", n -= o / 2) : (a = "[left] ", n += o / 2) : c > 0 ? (a = "[below] ", s -= 10) : (a = "[above] ", s += 10) } n *= this._scale, s *= this._scale; var l = e.replace(/{/g, "\\{"); l = l.replace(/}/g, "\\}"), this._texData += "\\draw (" + fixed(n, 2) + "," + fixed(-s, 2) + ") node " + a + "{$" + l.replace(/ /g, "\\mbox{ }") + "$};\n" } }, this.translate = this.save = this.restore = this.clearRect = function () { } } function ExportAsSVG(t) { this.width = t[2] - t[0], this.height = t[3] - t[1], this.bounds = t, this.fillStyle = "black", this.strokeStyle = "black", this.lineWidth = 1, this.font = "12px Arial, sans-serif", this._points = [], this._svgData = "", this._transX = 0, this._transY = 0, this.toSVG = function () { return function (t) { let e = t.replace(/<!--[\s\S]*?-->/g, ""); return e = e.replace(/>[\s\r\n]+</g, "><"), e = e.replace(/\s{2,}/g, " ").trim(), e = e.replace(/\s*=\s*/g, "=").replace(/,\s*/g, ","), e }(`<svg width="${this.width}" height="${this.height}" version="1.1" xmlns="http://www.w3.org/2000/svg">${this._svgData}</svg>`) }, this.beginPath = function () { this._points = [] }, this.arc = function (t, e, n, s, i, a) { t -= this.bounds[0], e -= this.bounds[1], t += this._transX, e += this._transY; var o = `stroke="${this.strokeStyle}" stroke-width="${this.lineWidth}" fill="none"`; if (i - s == 2 * Math.PI) this._svgData += "\t<ellipse " + o + ' cx="' + fixed(t, 3) + '" cy="' + fixed(e, 3) + '" rx="' + fixed(n, 3) + '" ry="' + fixed(n, 3) + '"/>'; else { if (a) { var r = s; s = i, i = r } i < s && (i += 2 * Math.PI); var c = t + n * Math.cos(s), l = e + n * Math.sin(s), d = t + n * Math.cos(i), h = e + n * Math.sin(i), u = Math.abs(i - s) > Math.PI; this._svgData += "\t<path " + o + ' d="', this._svgData += "M " + fixed(c, 3) + "," + fixed(l, 3) + " ", this._svgData += "A " + fixed(n, 3) + "," + fixed(n, 3) + " ", this._svgData += "0 ", this._svgData += +u + " ", this._svgData += "1 ", this._svgData += fixed(d, 3) + "," + fixed(h, 3), this._svgData += '"/>' } }, this.moveTo = this.lineTo = function (t, e) { t -= this.bounds[0], e -= this.bounds[1], t += this._transX, e += this._transY, this._points.push({ x: t, y: e }) }, this.stroke = function () { if (0 != this._points.length) { this._svgData += '\t<polygon stroke="' + this.strokeStyle + '" stroke-width="' + this.lineWidth + '" points="'; for (var t = 0; t < this._points.length; t++)this._svgData += (t > 0 ? " " : "") + fixed(this._points[t].x, 3) + "," + fixed(this._points[t].y, 3); this._svgData += '"/>' } }, this.fill = function () { if (0 != this._points.length) { this._svgData += '\t<polygon fill="' + this.fillStyle + '" stroke-width="' + this.lineWidth + '" points="'; for (var t = 0; t < this._points.length; t++)this._svgData += (t > 0 ? " " : "") + fixed(this._points[t].x, 3) + "," + fixed(this._points[t].y, 3); this._svgData += '"/>' } }, this.measureText = function (t) { var e = canvas.getContext("2d"); return e.font = '20px "Times New Romain", serif', e.measureText(t) }, this.fillText = function (t, e, n) { e -= this.bounds[0], n -= this.bounds[1], e += this._transX, n += this._transY, t.replace(" ", "").length > 0 && (this._svgData += '\t<text x="' + fixed(e, 3) + '" y="' + fixed(n, 3) + '" font-family="Times New Roman" font-size="20">' + textToXML(t) + "</text>") }, this.translate = function (t, e) { this._transX = t, this._transY = e }, this.save = this.restore = this.clearRect = function () { } } function convertLatexShortcuts(t) { const e = { emptyset: 8709, rightarrow: 8594, leftarrow: 8592, eps: 949, epsilon: 949 }; Object.keys(e).forEach((n => { t = t.replace(new RegExp(`\\\\${n}`, "g"), String.fromCharCode(e[n])) }));["Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Zeta", "Eta", "Theta", "Iota", "Kappa", "Lambda", "Mu", "Nu", "Xi", "Omicron", "Pi", "Rho", "Sigma", "Tau", "Upsilon", "Phi", "Chi", "Psi", "Omega"].forEach(((n, s) => { if (e[n.toLowerCase()]) return; const i = 913 + s + (s >= 16), a = 945 + s + (s >= 16); t = (t = t.replace(new RegExp(`\\\\${n}`, "g"), String.fromCharCode(i))).replace(new RegExp(`\\\\${n.toLowerCase()}`, "g"), String.fromCharCode(a)) })); for (let e = 0; e < 10; e++)t = t.replace(new RegExp(`_${e}`, "g"), String.fromCharCode(8320 + e)); return t } function textToXML(t) { t = t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); for (var e = "", n = 0; n < t.length; n++) { var s = t.charCodeAt(n); e += s >= 32 && s <= 126 ? t[n] : "&#" + s + ";" } return e } function drawArrow(t, e, n, s) { var i = Math.cos(s), a = Math.sin(s); t.beginPath(), t.moveTo(e, n), t.lineTo(e - 8 * i + 5 * a, n - 8 * a - 5 * i), t.lineTo(e - 8 * i - 5 * a, n - 8 * a + 5 * i), t.fill() } function canvasHasFocus() { return (document.activeElement || document.body) == document.body } function drawText(t, e, n, s, i, a) { text = convertLatexShortcuts(e), t.font = '20px "Times New Roman", serif'; var o = t.measureText(text).width; if (n -= o / 2, null != i) { var r = Math.cos(i), c = Math.sin(i), l = (o / 2 + 5) * (r > 0 ? 1 : -1), d = 15 * (c > 0 ? 1 : -1), h = c * Math.pow(Math.abs(c), 40) * l - r * Math.pow(Math.abs(r), 10) * d; n += l - c * h, s += d + r * h } "advancedFillText" in t ? t.advancedFillText(text, e, n + o / 2, s, i) : (n = Math.round(n), s = Math.round(s), t.fillText(text, n, s + 6), a && caretVisible && canvasHasFocus() && document.hasFocus() && (n += o, t.beginPath(), t.moveTo(n, s - 10), t.lineTo(n, s + 10), t.stroke())) } var caretTimer; Link.prototype.getAnchorPoint = function () { var t = this.nodeB.x - this.nodeA.x, e = this.nodeB.y - this.nodeA.y, n = Math.sqrt(t * t + e * e); return { x: this.nodeA.x + t * this.parallelPart - e * this.perpendicularPart / n, y: this.nodeA.y + e * this.parallelPart + t * this.perpendicularPart / n } }, Link.prototype.setAnchorPoint = function (t, e) { var n = this.nodeB.x - this.nodeA.x, s = this.nodeB.y - this.nodeA.y, i = Math.sqrt(n * n + s * s); this.parallelPart = (n * (t - this.nodeA.x) + s * (e - this.nodeA.y)) / (i * i), this.perpendicularPart = (n * (e - this.nodeA.y) - s * (t - this.nodeA.x)) / i, this.parallelPart > 0 && this.parallelPart < 1 && Math.abs(this.perpendicularPart) < snapToPadding && (this.lineAngleAdjust = (this.perpendicularPart < 0) * Math.PI, this.perpendicularPart = 0) }, Link.prototype.getEndPointsAndCircle = function () { if (0 == this.perpendicularPart) { var t = (this.nodeA.x + this.nodeB.x) / 2, e = (this.nodeA.y + this.nodeB.y) / 2, n = this.nodeA.closestPointOnCircle(t, e), s = this.nodeB.closestPointOnCircle(t, e); return { hasCircle: !1, startX: n.x, startY: n.y, endX: s.x, endY: s.y } } var i = this.getAnchorPoint(), a = circleFromThreePoints(this.nodeA.x, this.nodeA.y, this.nodeB.x, this.nodeB.y, i.x, i.y), o = this.perpendicularPart > 0, r = o ? 1 : -1, c = Math.atan2(this.nodeA.y - a.y, this.nodeA.x - a.x) - r * nodeRadius / a.radius, l = Math.atan2(this.nodeB.y - a.y, this.nodeB.x - a.x) + r * nodeRadius / a.radius; return { hasCircle: !0, startX: a.x + a.radius * Math.cos(c), startY: a.y + a.radius * Math.sin(c), endX: a.x + a.radius * Math.cos(l), endY: a.y + a.radius * Math.sin(l), startAngle: c, endAngle: l, circleX: a.x, circleY: a.y, circleRadius: a.radius, reverseScale: r, isReversed: o } }, Link.prototype.draw = function (t) { var e = this.getEndPointsAndCircle(); if (t.beginPath(), e.hasCircle ? t.arc(e.circleX, e.circleY, e.circleRadius, e.startAngle, e.endAngle, e.isReversed) : (t.moveTo(e.startX, e.startY), t.lineTo(e.endX, e.endY)), t.stroke(), e.hasCircle ? drawArrow(t, e.endX, e.endY, e.endAngle - e.reverseScale * (Math.PI / 2)) : drawArrow(t, e.endX, e.endY, Math.atan2(e.endY - e.startY, e.endX - e.startX)), e.hasCircle) { var n = e.startAngle, s = e.endAngle; s < n && (s += 2 * Math.PI); var i = (n + s) / 2 + e.isReversed * Math.PI, a = e.circleX + e.circleRadius * Math.cos(i), o = e.circleY + e.circleRadius * Math.sin(i); drawText(t, this.text, a, o, i, selectedObject == this) } else { a = (e.startX + e.endX) / 2, o = (e.startY + e.endY) / 2, i = Math.atan2(e.endX - e.startX, e.startY - e.endY); drawText(t, this.text, a, o, i + this.lineAngleAdjust, selectedObject == this) } }, Link.prototype.containsPoint = function (t, e) { var n = this.getEndPointsAndCircle(); if (!n.hasCircle) { a = n.endX - n.startX, o = n.endY - n.startY; var s = Math.sqrt(a * a + o * o), i = (a * (t - n.startX) + o * (e - n.startY)) / (s * s); r = (a * (e - n.startY) - o * (t - n.startX)) / s; return i > 0 && i < 1 && Math.abs(r) < hitTargetPadding } var a = t - n.circleX, o = e - n.circleY, r = Math.sqrt(a * a + o * o) - n.circleRadius; if (Math.abs(r) < hitTargetPadding) { var c = Math.atan2(o, a), l = n.startAngle, d = n.endAngle; if (n.isReversed) { var h = l; l = d, d = h } return d < l && (d += 2 * Math.PI), c < l ? c += 2 * Math.PI : c > d && (c -= 2 * Math.PI), c > l && c < d } return !1 }, Node.prototype.setMouseStart = function (t, e) { this.mouseOffsetX = this.x - t, this.mouseOffsetY = this.y - e }, Node.prototype.setAnchorPoint = function (t, e) { this.x = t + this.mouseOffsetX, this.y = e + this.mouseOffsetY }, Node.prototype.draw = function (t) { this.textOnly ? drawText(t, this.text, this.x, this.y, null, selectedObject == this) : (t.beginPath(), t.arc(this.x, this.y, nodeRadius, 0, 2 * Math.PI, !1), t.stroke(), drawText(t, this.text, this.x, this.y, null, selectedObject == this), this.isAcceptState && (t.beginPath(), t.arc(this.x, this.y, nodeRadius - 6, 0, 2 * Math.PI, !1), t.stroke())) }, Node.prototype.closestPointOnCircle = function (t, e) { var n = t - this.x, s = e - this.y, i = Math.sqrt(n * n + s * s); return { x: this.x + n * nodeRadius / i, y: this.y + s * nodeRadius / i } }, Node.prototype.containsPoint = function (t, e) { return (t - this.x) * (t - this.x) + (e - this.y) * (e - this.y) < nodeRadius * nodeRadius }, SelfLink.prototype.setMouseStart = function (t, e) { this.mouseOffsetAngle = this.anchorAngle - Math.atan2(e - this.node.y, t - this.node.x) }, SelfLink.prototype.setAnchorPoint = function (t, e) { this.anchorAngle = Math.atan2(e - this.node.y, t - this.node.x) + this.mouseOffsetAngle; var n = Math.round(this.anchorAngle / (Math.PI / 2)) * (Math.PI / 2); Math.abs(this.anchorAngle - n) < .1 && (this.anchorAngle = n), this.anchorAngle < -Math.PI && (this.anchorAngle += 2 * Math.PI), this.anchorAngle > Math.PI && (this.anchorAngle -= 2 * Math.PI) }, SelfLink.prototype.getEndPointsAndCircle = function () { var t = this.node.x + 1.5 * nodeRadius * Math.cos(this.anchorAngle), e = this.node.y + 1.5 * nodeRadius * Math.sin(this.anchorAngle), n = .75 * nodeRadius, s = this.anchorAngle - .8 * Math.PI, i = this.anchorAngle + .8 * Math.PI; return { hasCircle: !0, startX: t + n * Math.cos(s), startY: e + n * Math.sin(s), endX: t + n * Math.cos(i), endY: e + n * Math.sin(i), startAngle: s, endAngle: i, circleX: t, circleY: e, circleRadius: n } }, SelfLink.prototype.draw = function (t) { var e = this.getEndPointsAndCircle(); t.beginPath(), t.arc(e.circleX, e.circleY, e.circleRadius, e.startAngle, e.endAngle, !1), t.stroke(); var n = e.circleX + e.circleRadius * Math.cos(this.anchorAngle), s = e.circleY + e.circleRadius * Math.sin(this.anchorAngle); drawText(t, this.text, n, s, this.anchorAngle, selectedObject == this), drawArrow(t, e.endX, e.endY, e.endAngle + .4 * Math.PI) }, SelfLink.prototype.containsPoint = function (t, e) { var n = this.getEndPointsAndCircle(), s = t - n.circleX, i = e - n.circleY, a = Math.sqrt(s * s + i * i) - n.circleRadius; return Math.abs(a) < hitTargetPadding }, StartLink.prototype.setAnchorPoint = function (t, e) { this.deltaX = t - this.node.x, this.deltaY = e - this.node.y, Math.abs(this.deltaX) < snapToPadding && (this.deltaX = 0), Math.abs(this.deltaY) < snapToPadding && (this.deltaY = 0) }, StartLink.prototype.getEndPoints = function () { var t = this.node.x + this.deltaX, e = this.node.y + this.deltaY, n = this.node.closestPointOnCircle(t, e); return { startX: t, startY: e, endX: n.x, endY: n.y } }, StartLink.prototype.draw = function (t) { var e = this.getEndPoints(); t.beginPath(), t.moveTo(e.startX, e.startY), t.lineTo(e.endX, e.endY), t.stroke(); var n = Math.atan2(e.startY - e.endY, e.startX - e.endX); drawText(t, this.text, e.startX, e.startY, n, selectedObject == this), drawArrow(t, e.endX, e.endY, Math.atan2(-this.deltaY, -this.deltaX)) }, StartLink.prototype.containsPoint = function (t, e) { var n = this.getEndPoints(), s = n.endX - n.startX, i = n.endY - n.startY, a = Math.sqrt(s * s + i * i), o = (s * (t - n.startX) + i * (e - n.startY)) / (a * a), r = (s * (e - n.startY) - i * (t - n.startX)) / a; return o > 0 && o < 1 && Math.abs(r) < hitTargetPadding }, TemporaryLink.prototype.draw = function (t) { t.beginPath(), t.moveTo(this.to.x, this.to.y), t.lineTo(this.from.x, this.from.y), t.stroke(), drawArrow(t, this.to.x, this.to.y, Math.atan2(this.to.y - this.from.y, this.to.x - this.from.x)) }; var canvas, caretVisible = !0; function resetCaret() { clearInterval(caretTimer), caretTimer = setInterval("caretVisible = !caretVisible; draw()", 500), caretVisible = !0 } var originalClick, nodeRadius = 30, nodes = [], links = [], cursorVisible = !0, snapToPadding = 6, hitTargetPadding = 6, selectedObject = null, currentLink = null, movingObject = !1; function clearCanvas() { nodes = [], links = [], localStorage.removeItem("fsm"), canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height), nodeRadius = 30, document.getElementById("rangeSlider").value = 30 } function makeNodeTextOnly() { "textOnly" in selectedObject && (selectedObject.textOnly = !selectedObject.textOnly, draw()) } function radiusChanged() { var t = document.getElementById("rangeSlider").value; t = parseInt(t), nodeRadius = t, draw() } function drawUsing(t) { t.clearRect(0, 0, canvas.width, canvas.height), t.save(), t.translate(.5, .5); for (var e = 0; e < nodes.length; e++)t.lineWidth = 1, t.fillStyle = t.strokeStyle = nodes[e] == selectedObject ? "blue" : "black", nodes[e].draw(t); for (e = 0; e < links.length; e++)t.lineWidth = 1, t.fillStyle = t.strokeStyle = links[e] == selectedObject ? "blue" : "black", links[e].draw(t); null != currentLink && (t.lineWidth = 1, t.fillStyle = t.strokeStyle = "black", currentLink.draw(t)), t.restore() } function draw() { drawUsing(canvas.getContext("2d")), saveBackup() } function selectObject(t, e) { for (var n = 0; n < nodes.length; n++)if (nodes[n].containsPoint(t, e)) return nodes[n]; for (n = 0; n < links.length; n++)if (links[n].containsPoint(t, e)) return links[n]; return null } function snapNode(t) { for (var e = 0; e < nodes.length; e++)nodes[e] != t && (Math.abs(t.x - nodes[e].x) < snapToPadding && (t.x = nodes[e].x), Math.abs(t.y - nodes[e].y) < snapToPadding && (t.y = nodes[e].y)) } window.onload = function () { canvas = document.getElementById("canvas"), restoreBackup(), draw(), canvas.onmousedown = function (t) { var e = crossBrowserRelativeMousePos(t); return selectedObject = selectObject(e.x, e.y), movingObject = !1, originalClick = e, null != selectedObject ? (shift && selectedObject instanceof Node ? currentLink = new SelfLink(selectedObject, e) : (movingObject = !0, deltaMouseX = deltaMouseY = 0, selectedObject.setMouseStart && selectedObject.setMouseStart(e.x, e.y)), resetCaret()) : shift && (currentLink = new TemporaryLink(e, e)), draw(), !canvasHasFocus() && (resetCaret(), !0) }, canvas.ondblclick = function (t) { var e = crossBrowserRelativeMousePos(t); null == (selectedObject = selectObject(e.x, e.y)) ? (selectedObject = new Node(e.x, e.y), nodes.push(selectedObject), resetCaret(), draw()) : selectedObject instanceof Node && (selectedObject.isAcceptState = !selectedObject.isAcceptState, draw()) }, canvas.onmousemove = function (t) { var e = crossBrowserRelativeMousePos(t); if (null != currentLink) { var n = selectObject(e.x, e.y); n instanceof Node || (n = null), currentLink = null == selectedObject ? null != n ? new StartLink(n, originalClick) : new TemporaryLink(originalClick, e) : n == selectedObject ? new SelfLink(selectedObject, e) : null != n ? new Link(selectedObject, n) : new TemporaryLink(selectedObject.closestPointOnCircle(e.x, e.y), e), draw() } movingObject && (selectedObject.setAnchorPoint(e.x, e.y), selectedObject instanceof Node && snapNode(selectedObject), draw()) }, canvas.onmouseup = function (t) { movingObject = !1, null != currentLink && (currentLink instanceof TemporaryLink || (selectedObject = currentLink, links.push(currentLink), resetCaret()), currentLink = null, draw()) } }; var shift = !1; function crossBrowserKey(t) { return (t = t || window.event).which || t.keyCode } function crossBrowserElementPos(t) { for (var e = (t = t || window.event).target || t.srcElement, n = 0, s = 0; e.offsetParent;)n += e.offsetLeft, s += e.offsetTop, e = e.offsetParent; return { x: n, y: s } } function crossBrowserMousePos(t) { return { x: (t = t || window.event).pageX || t.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, y: t.pageY || t.clientY + document.body.scrollTop + document.documentElement.scrollTop } } function crossBrowserRelativeMousePos(t) { var e = crossBrowserElementPos(t), n = crossBrowserMousePos(t); return { x: n.x - e.x, y: n.y - e.y } } function output(t) { var e = document.getElementById("output"); e.style.display = "block", e.value = t } function saveAsPNG() { var t = selectedObject; selectedObject = null, drawUsing(canvas.getContext("2d")), selectedObject = t; var e = getBoundingRect(), n = e[2] - e[0], s = e[3] - e[1], i = canvas.getContext("2d").getImageData(e[0], e[1], n, s), a = document.createElement("canvas"); a.width = n, a.height = s, a.getContext("2d").putImageData(i, 0, 0); var o = a.toDataURL("image/png"), r = document.createElement("a"); r.href = o, r.download = "image.png", document.body.appendChild(r), r.click(), document.body.removeChild(r) } function getBoundingRect() { for (var t = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), e = function (t) { var e = Math.floor(t / 4); return [Math.floor(e % canvas.width), Math.floor(e / canvas.width)] }, n = -1, s = canvas.width + 1, i = -1, a = canvas.height + 1, o = 0; o < t.data.length; o++)if (0 != t.data[o]) { var r = e(o), c = r[0], l = r[1]; c < s && (s = c), c > n && (n = c), l < a && (a = l), l > i && (i = l) } if (s >= n) return [0, 0, canvas.width, canvas.height]; return i += 2, (s -= 2) < 0 && (s = 0), (a -= 2) < 0 && (a = 0), (n += 2) > canvas.width && (n = canvas.width), i > canvas.width && (i = canvas.width), [s, a, n, i] } function downloadFile(t, e, n) { var s = document.createElement("a"); s.setAttribute("href", "data:" + n + ";base64," + btoa(e)), s.setAttribute("download", t), s.style.display = "none", document.body.appendChild(s), s.click(), document.body.removeChild(s) } function downloadSVGFile(t, e) { downloadFile(t, e, "image/svg+xml") } function saveAsSVG() { var t = new ExportAsSVG(getBoundingRect()), e = selectedObject; selectedObject = null, drawUsing(t), selectedObject = e, downloadSVGFile("automaton.svg", t.toSVG()) } function copySVGToClipboard() { var t = new ExportAsSVG(getBoundingRect()), e = selectedObject; selectedObject = null, drawUsing(t), selectedObject = e; var n = t.toSVG(); navigator.clipboard && window.isSecureContext ? navigator.clipboard.writeText(n).then((function () { console.log("SVG data copied to clipboard successfully!") }), (function (t) { console.error("Could not copy SVG data to clipboard: ", t) })) : console.error("Clipboard API not available or not in a secure context.") } function copyLaTeXToClipboard() { var t = new ExportAsLaTeX(getBoundingRect()), e = selectedObject; selectedObject = null, drawUsing(t), selectedObject = e; var n = t.toLaTeX(); navigator.clipboard && window.isSecureContext ? navigator.clipboard.writeText(n).then((function () { console.log("LaTeX data copied to clipboard successfully!") }), (function (t) { console.error("Could not copy LaTeX data to clipboard: ", t) })) : console.error("Clipboard API not available or not in a secure context.") } function saveAsJSON() { downloadFile("automaton_backup.json", JSON.stringify(getBackupData()), "text/json") } function jsonUploaded() { var t = document.getElementById("jsonUpload"); if (!(t.files.length < 1)) { var e = t.files[0], n = new FileReader; n.onload = function (t) { var n = t.target.result; try { var s = JSON.parse(n); clearCanvas(), restoreFromBackupData(s) } catch (t) { alert("Failed loading file " + e.name) } }, n.readAsText(e) } } function uploadJSON() { document.getElementById("jsonUpload").click() } function det(t, e, n, s, i, a, o, r, c) { return t * i * c + e * a * o + n * s * r - t * a * r - e * s * c - n * i * o } function circleFromThreePoints(t, e, n, s, i, a) { var o = det(t, e, 1, n, s, 1, i, a, 1), r = -det(t * t + e * e, e, 1, n * n + s * s, s, 1, i * i + a * a, a, 1), c = det(t * t + e * e, t, 1, n * n + s * s, n, 1, i * i + a * a, i, 1), l = -det(t * t + e * e, t, e, n * n + s * s, n, s, i * i + a * a, i, a); return { x: -r / (2 * o), y: -c / (2 * o), radius: Math.sqrt(r * r + c * c - 4 * o * l) / (2 * Math.abs(o)) } } function fixed(t, e) { return t.toFixed(e).replace(/0+$/, "").replace(/\.$/, "") } function restoreFromBackupData(t) { for (var e = 0; e < t.nodes.length; e++) { var n = t.nodes[e], s = new Node(n.x, n.y); s.isAcceptState = n.isAcceptState, s.text = n.text, s.textOnly = n.textOnly, nodes.push(s) } for (e = 0; e < t.links.length; e++) { var i = t.links[e], a = null; "SelfLink" == i.type ? ((a = new SelfLink(nodes[i.node])).anchorAngle = i.anchorAngle, a.text = i.text) : "StartLink" == i.type ? ((a = new StartLink(nodes[i.node])).deltaX = i.deltaX, a.deltaY = i.deltaY, a.text = i.text) : "Link" == i.type && ((a = new Link(nodes[i.nodeA], nodes[i.nodeB])).parallelPart = i.parallelPart, a.perpendicularPart = i.perpendicularPart, a.text = i.text, a.lineAngleAdjust = i.lineAngleAdjust), null != a && links.push(a) } nodeRadius = t.nodeRadius, draw() } function restoreBackup() { if (localStorage && JSON) try { restoreFromBackupData(JSON.parse(localStorage.fsm)) } catch (t) { localStorage.fsm = "" } } function getBackupData() { for (var t = { nodes: [], links: [], nodeRadius: nodeRadius }, e = 0; e < nodes.length; e++) { var n = nodes[e], s = { x: n.x, y: n.y, text: n.text, isAcceptState: n.isAcceptState, textOnly: n.textOnly }; t.nodes.push(s) } for (e = 0; e < links.length; e++) { var i = links[e], a = null; i instanceof SelfLink ? a = { type: "SelfLink", node: nodes.indexOf(i.node), text: i.text, anchorAngle: i.anchorAngle } : i instanceof StartLink ? a = { type: "StartLink", node: nodes.indexOf(i.node), text: i.text, deltaX: i.deltaX, deltaY: i.deltaY } : i instanceof Link && (a = { type: "Link", nodeA: nodes.indexOf(i.nodeA), nodeB: nodes.indexOf(i.nodeB), text: i.text, lineAngleAdjust: i.lineAngleAdjust, parallelPart: i.parallelPart, perpendicularPart: i.perpendicularPart }), null != a && t.links.push(a) } return t } function saveBackup() { if (localStorage && JSON) { var t = getBackupData(); localStorage.fsm = JSON.stringify(t) } } document.onkeydown = function (t) { var e = crossBrowserKey(t); if (16 == e) shift = !0; else { if (!canvasHasFocus()) return !0; if (8 == e) return null != selectedObject && "text" in selectedObject && (selectedObject.text = selectedObject.text.substr(0, selectedObject.text.length - 1), resetCaret(), draw()), !1; if (46 == e && null != selectedObject) { for (var n = 0; n < nodes.length; n++)nodes[n] == selectedObject && nodes.splice(n--, 1); for (n = 0; n < links.length; n++)links[n] != selectedObject && links[n].node != selectedObject && links[n].nodeA != selectedObject && links[n].nodeB != selectedObject || links.splice(n--, 1); selectedObject = null, draw() } } }, document.onkeyup = function (t) { 16 == crossBrowserKey(t) && (shift = !1) }, document.onkeypress = function (t) { var e = crossBrowserKey(t); return !canvasHasFocus() || (e >= 32 && e <= 126 && !t.metaKey && !t.altKey && !t.ctrlKey && null != selectedObject && "text" in selectedObject ? (selectedObject.text += String.fromCharCode(e), resetCaret(), draw(), !1) : 8 != e && void 0) };