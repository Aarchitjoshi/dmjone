<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Adjacency Matrix</title>
    <meta name="description" content="Understand the representations of graphs using adjacency matrix and adjacency list. Dive into the topic of graph representations with CSU1051 course at Shoolini University, covering data structures and algorithms.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Adjacency Matrix
        </h2>
        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#summary"><i class="fas fa-chevron-circle-right"></i> Executive Summary</a></li>
                    <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#graph-basics"><i class="fas fa-chevron-circle-right"></i> Graph Basics</a></li>
                    <li class="p-1"><a href="#graph-representations"><i class="fas fa-chevron-circle-right"></i> Graph Representations</a></li>
                    <li class="p-1"><a href="#incidence-matrix-list"><i class="fas fa-chevron-circle-right"></i> Incidence Matrix List</a></li>
                    <li class="p-1"><a href="#conclusion"><i class="fas fa-chevron-circle-right"></i> Conclusion</a></li>
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>



      <article id="adjacency-matrix-intro">
        <h3>1. Introduction to Adjacency Matrices</h3>
        <p>An adjacency matrix is a fundamental concept in computer science, specifically within the domain of data structures and algorithms. It is used to represent graphs as binary or weighted matrices. The nodes of the graph are associated with the rows and columns of the matrix, with matrix elements indicating whether an edge is present between the nodes.</p>

        <p>An adjacency matrix can be used to represent both directed and undirected graphs, simple or multigraphs, and can also be extended to represent weighted graphs. Its uses are widespread, finding applications in various computer science subfields such as network analysis, path finding, and scheduling problems.</p>
      </article>

      <article id="adjacency-matrix-basic">
        <h3>2. The Basic Concept of Adjacency Matrices</h3>
        <p>The adjacency matrix for a graph with 'n' vertices is a square 'n × n' matrix where the entry in the i-th row and j-th column is usually a 0 or 1, depending on whether there is an edge from vertex i to vertex j.</p>

        <p>In the case of an undirected graph, the adjacency matrix is symmetric about the main diagonal, as the presence of an edge from i to j implies the presence of an edge from j to i. However, this is not the case for a directed graph, which results in an asymmetric adjacency matrix.</p>

        <p>In weighted graphs, the weights of the edges can be represented as entries in the adjacency matrix. If there is no edge between two vertices, the entries are usually filled with a specific value to denote "no edge," often zero or infinity.</p>
      </article>

      <article id="advantages-limitations">
        <h4>2.1 Advantages and Limitations of Adjacency Matrices</h4>
        <p>Adjacency matrices come with their own set of advantages and limitations. They are straightforward to implement and provide a quick way to check if a specific edge is in the graph - this operation can be performed in constant time, i.e., O(1).</p>

        <p>However, for a sparse graph (one with few edges), an adjacency matrix may not be the most space-efficient representation. Each adjacency matrix consumes O(n²) space, regardless of the number of edges in the graph. In such cases, an adjacency list might be a more efficient choice.</p>

        <p>Another drawback is the time complexity for traversing all the edges of a graph, which takes O(n²) time for an adjacency matrix, while an adjacency list can perform this in O(n + m) time, where m is the number of edges.</p>
      </article>

      <article id="representation-in-cpp">
        <h3>3. Representation of Adjacency Matrices in C++</h3>
        <p>Implementing an adjacency matrix in C++ is straightforward. A two-dimensional array can be used to represent the matrix, and standard library functions can manipulate it. Here's a simple implementation:</p>

        <pre><code class="language-cpp">
#include<bits/stdc++.h>
using namespace std;

int main() {
    int vertices, edges, i, j;
    cin >> vertices >> edges;

    // Create a 2D array of size vertices x vertices
    vector<vector<int>> adjMatrix(vertices, vector<int>(vertices, 0));

    for(int e = 0; e < edges; e++) {
        cin >> i >> j;
        adjMatrix[i][j] = 1;
        adjMatrix[j][i] = 1; // Remove this for a directed graph
    }

    return 0;
}
</code></pre>

        <p>In the code above, we first create

          a square matrix with all elements initialized to zero. Then for each edge in the graph, we set the corresponding element in the adjacency matrix to one.</p>
      </article>

      <article id="operations-on-adjacency-matrices">
        <h3>4. Operations on Adjacency Matrices</h3>
        <p>Various operations can be performed on adjacency matrices, such as adding a vertex, adding an edge, removing a vertex, removing an edge, and checking if an edge exists between two vertices.</p>
      </article>

      <article id="add-remove-vertex">
        <h4>4.1 Adding and Removing a Vertex</h4>
        <p>To add a vertex, we need to add another row and column to our matrix. In C++, this can be done by resizing our matrix and filling the new entries with zeros:</p>

        <pre><code class="language-cpp">
adjMatrix.resize(vertices + 1);
for(int i = 0; i <= vertices; i++) {
    adjMatrix[i].resize(vertices + 1, 0);
}
</code></pre>

        <p>To remove a vertex, we need to delete the corresponding row and column from our matrix. This can be done by creating a new matrix without the deleted vertex and then assigning it to our original matrix:</p>

        <pre><code class="language-cpp">
vector<vector<int>> newMatrix(vertices - 1, vector<int>(vertices - 1, 0));
for(int i = 0; i < vertices; i++) {
    for(int j = 0; j < vertices; j++) {
        if(i != deletedVertex && j != deletedVertex) {
            newMatrix[i < deletedVertex ? i : i - 1][j < deletedVertex ? j : j - 1] = adjMatrix[i][j];
        }
    }
}
adjMatrix = newMatrix;
</code></pre>
      </article>

      <article id="add-remove-edge">
        <h4>4.2 Adding and Removing an Edge</h4>
        <p>To add an edge, we simply need to update the corresponding entry in our matrix to one:</p>

        <pre><code class="language-cpp">
adjMatrix[i][j] = 1;
</code></pre>

        <p>Similarly, to remove an edge, we update the corresponding entry in our matrix back to zero:</p>

        <pre><code class="language-cpp">
adjMatrix[i][j] = 0;
</code></pre>
      </article>

      <article id="check-edge">
        <h4>4.3 Checking if an Edge Exists</h4>
        <p>To check if an edge exists between two vertices, we simply need to check the value of the corresponding entry in our matrix:</p>

        <pre><code class="language-cpp">
if(adjMatrix[i][j] == 1) {
    cout << "Edge exists.\n";
} else {
    cout << "Edge does not exist.\n";
}
</code></pre>
      </article>

      <article id="advanced-concepts">
        <h3>5. Advanced Concepts and Applications of Adjacency Matrices</h3>
        <p>Adjacency matrices form the foundation for many advanced graph algorithms. They can be used to compute the transitive closure of a graph, determine the presence of a triangle in a graph, or find the shortest path between two vertices using algorithms such as Floyd-Warshall.</p>

        <p>In addition to these, adjacency matrices have found use in social network analysis, image processing, and even in the study of biological networks such as protein-protein interaction networks or metabolic networks.</p>
      </article>

      <article id="conclusion">
        <h3>6. Conclusion</h3>
        <p>Adjacency matrices are powerful tools in the field of data structures and algorithms. They provide an efficient and intuitive way to represent graphs and perform operations on them. Despite their limitations, particularly with sparse graphs, they are instrumental in a wide array of applications.</p>
      </article>

      <article id="next-article-prompt">
        <h3>A Peek into the Next Chapter...</h3>
        <p>Are you ready for the next leap in your journey with graphs? Well, hold on to your curiosity as we unravel the power of adjacency lists in our next chapter "Adjacency Lists: A Gateway to Efficient Graph Traversal". Here, we will take a deep dive into the realm of adjacency lists, their efficient memory usage, and their edge in traversing sparse graphs. So, keep your C++ compilers warmed up and stay tuned!</p>
      </article>


      <article id="introduction">
        <h3>1. Introduction to Graphs and Adjacency Matrices</h3>
        <p>Graphs are fundamental data structures that consist of a finite set of vertices (or nodes) and a set of edges connecting these vertices. They are widely used in computer science and mathematics to model relationships and connections between objects. One of the primary ways to represent a graph is using an adjacency matrix.</p>
      </article>
      <article id="adjacency-matrix-basics">
        <h3>2. The Basics of Adjacency Matrix</h3>
        <p>An adjacency matrix is a square matrix used to represent a finite graph. The size of the matrix is n x n, where n is the number of vertices in the graph. The element A<sub>ij</sub> is 1 if there is an edge between vertex i and vertex j; otherwise, it is 0. In the case of a weighted graph, the element A<sub>ij</sub> represents the weight of the edge between vertices i and j.</p>
        <p>In the special case of a finite simple graph, the adjacency matrix is a (0,1)-matrix with zeros on its diagonal. For undirected graphs, the adjacency matrix is symmetric. This is because if vertex i is adjacent to vertex j, vertex j is also adjacent to vertex i.</p>
      </article>
      <article id="spectral-graph-theory">
        <h4>2.1 Spectral Graph Theory</h4>
        <p>The relationship between a graph and the eigenvalues and eigenvectors of its adjacency matrix is studied in spectral graph theory. The set of eigenvalues of a graph is known as the spectrum of the graph. The spectrum and the eigenvalues of the adjacency matrix can provide insightful information about the structure of the graph.</p>
      </article>
      <article id="other-matrix-representations">
        <h4>2.2 Other Matrix Representations</h4>
        <p>It is important to distinguish the adjacency matrix from other matrix representations of a graph, such as the incidence matrix and the degree matrix. The incidence matrix has elements that indicate whether vertex-edge pairs are incident or not, while the degree matrix contains information about the degree of each vertex.</p>
      </article>
      <article id="complexity">
        <h3>3. Time Complexity and Memory Usage</h3>
        <p>The adjacency matrix representation of a graph requires O(n<sup>2</sup>) memory. The time complexity for operations such as checking if there is an edge between two vertices is O(1), which is constant time. However, adding or removing edges can take O(1) time, but adding or removing vertices can take O(n<sup>2</sup>) time because of the need to resize the matrix.</p>
        <p>Compared to adjacency lists, adjacency matrices have faster lookup times for checking the presence of specific edges, but can consume significantly more memory, especially in sparse graphs where the number of edges is much less than the number of vertices squared.</p>
      </article>
      <article id="applications">
        <h3>4. Applications of Adjacency Matrices</h3>
        <p>Adjacency matrices are widely used in various fields such as computer networks, social networks, image processing, and transportation. They are particularly useful in algorithms that require rapid access to graph's connectivity information. They are also used in algebraic graph theory.</p>
      </article>
      <article id="example-implementation">
        <h3>5. Example Implementation in C++</h3>
        <pre><code class="language-cpp"> 
#include &lt;iostream&gt;
#include &lt;vector&gt;
class Graph {
public:
Graph(int vertices) : adjMatrix(vertices, std::vector<int>(vertices, 0)),numVertices(vertices) {}
  void addEdge(int i, int j) {
    adjMatrix[i][j] = 1;
    adjMatrix[j][i] = 1;
}

void removeEdge(int i, int j) {
    adjMatrix[i][j] = 0;
    adjMatrix[j][i] = 0;
}

void printMatrix() {
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            std::cout << adjMatrix[i][j] << " ";
        }
        std::cout << std::endl;
    }
}
private:
std::vector<std::vector<int>> adjMatrix;
int numVertices;
};

int main() {
Graph graph(5);
graph.addEdge(0, 1);
graph.addEdge(0, 4);
graph.addEdge(1, 3);
graph.addEdge(1, 4);
graph.addEdge(3, 4);
graph.printMatrix();

return 0;
}
</code></pre>

      </article>
      <article id="conclusion">
        <h3>6. Conclusion</h3>
        <p>Adjacency matrices are a powerful tool for representing graphs, especially when rapid access to the graph's connectivity information is required. While they can consume more memory than alternative representations like adjacency lists, especially in sparse graphs, they have their own set of advantages including faster edge lookup times.</p>
      </article>
      <article id="next-article">
        <h3>Next Up: The Mystical World of Graph Traversals</h3>
        <p>Embark on an exciting journey in our next article as we delve into the mystical world of graph traversals. Discover the secrets of Depth-First Search (DFS) and Breadth-First Search (BFS), and how these algorithms can be used to solve complex problems and navigate through mazes of data. Stay tuned!</p>
      </article>



    </main>

    <script>copyright("all");</script>
  </body>

</html>