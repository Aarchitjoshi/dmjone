<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Array's representation in memory - CSU1051 - CSE 2026 - Shoolini University</title>
    <meta name="description" content="Know more about Array's representation in memory of data structure and algorithms. Tailored for the level from basic to computer science students.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Array's Representation in Memory
        </h2>
      </article>
      <article>
        <h3>1. Introduction to Arrays</h3>
        <p>An array is a fundamental data structure in computer programming that can store a fixed-size collection of elements, each of the same data type. Arrays allow us to organize and store multiple values in a single, contiguous block of memory, which can be easily accessed and manipulated using their indices. This article will discuss the representation of arrays in memory, focusing on addressing schemes, row-major and column-major order, and various implementation methods in C++.</p>
      </article>
      <article>
        <h4>1.1 Array Memory Layout</h4>
        <p>When an array is declared in a programming language like C++, it is allocated a contiguous block of memory to store its elements. Each element in the array is of the same data type, and therefore, they occupy the same amount of memory. The starting address of the array is the base address, and the address of each subsequent element can be calculated using the base address, the size of the data type, and the index of the element in the array.</p>
      </article>
      <article>
        <h5>1.1.1 Address Calculation Formula</h5>
        <p>To find the address of an element present in an array, the following formula can be used:</p>
        <p>$$Address(A[i]) = BaseAddress(A) + (i * sizeof(datatype))$$</p>
        <p>Where:</p>
        <ul>
          <li>$A$ is the array</li>
          <li>$BaseAddress(A)$ is the base address of the array</li>
          <li>$i$ is the index of the element</li>
          <li>$sizeof(datatype)$ is the size of the data type in bytes</li>
        </ul>
      </article>
      <article>
        <h5>1.1.2 Example: Address Calculation</h5>
        <pre><code class="language-cpp">// C++ code to demonstrate address calculation
#include &lt;iostream&gt;
int main() {
  int A[5] = {1, 2, 3, 4, 5};

  for (int i = 0; i < 5; ++i) {
    std::cout << "Address of A[" << i << "] = " << (uintptr_t)&A[i] << '\n';
  }

  return 0;
}</code></pre>

        <p>In the example above, we calculate the addresses of the elements in the integer array A using the '&' operator, which returns the address of a variable. The uintptr_t type is used to display the address as an unsigned integer.</p>
      </article>
      <article>
        <h4>1.2 Multi-Dimensional Arrays</h4>
        <p>Multi-dimensional arrays are arrays of arrays, commonly used to represent matrices, tables, and other structures with more than one dimension. The most common type of multi-dimensional array is a two-dimensional array, which can be visualized as a table with rows and columns. In this article, we will primarily focus on two-dimensional arrays, but the concepts discussed can be extended to higher dimensions.</p>
      </article>
      <article>
        <h5>1.2.1 Address Calculation for Multi-Dimensional Arrays</h5>
        <p>For a two-dimensional array $A$ with $m$ rows and $n$ columns, the address of the element at row $i$ and column $j$ can be calculated using the following formula:</p>
        <p>$$Address(A[i][j]) = BaseAddress(A) + ((i * n) + j) * sizeof(datatype)$$</p>
        <p>Where:</p>
        <ul>
          <li>$A$ is the two-dimensional array</li>

          <li>$BaseAddress(A)$ is the base address of the array</li>
          <li>$i$ is the row index</li>
          <li>$j$ is the column index</li>
          <li>$m$ is the number of rows</li>
          <li>$n$ is the number of columns</li>
          <li>$sizeof(datatype)$ is the size of the data type in bytes</li>
        </ul>
      </article>
      <article>
        <h5>1.2.2 Example: Address Calculation for a 2D Array</h5>
        <pre><code class="language-cpp">// C++ code to demonstrate address calculation for a 2D array
#include &lt;iostream&gt;
int main() {
  int A[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
  };

  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 4; ++j) {
      std::cout << "Address of A[" << i << "][" << j << "] = " << (uintptr_t)&A[i][j] << '\n';
    }
  }

  return 0;
}</code></pre>

        <p>In the example above, we calculate the addresses of the elements in the 2D integer array A using a nested loop and the '&' operator. The uintptr_t type is used to display the address as an unsigned integer.</p>
      </article>
      <article>
        <h4>1.3 Row-Major and Column-Major Order</h4>
        <p>When storing multi-dimensional arrays in memory, there are two primary layouts used: row-major order and column-major order. The choice of layout determines the order in which the elements are stored in memory and can have an impact on the performance of algorithms that access the array.</p>
      </article>
      <article>
        <h5>1.3.1 Row-Major Order</h5>
        <p>In row-major order, the elements of a multi-dimensional array are stored in memory row by row. This means that the elements in the first row are stored first, followed by the elements in the second row, and so on. In C++, arrays are stored in row-major order by default.</p>
        <p>For a two-dimensional array $A$ with $m$ rows and $n$ columns, the address of the element at row $i$ and column $j$ in row-major order can be calculated using the following formula:</p>
        <p>$$Address(A[i][j]) = BaseAddress(A) + ((i * n) + j) * sizeof(datatype)$$</p>
        <p>This is the same formula we used earlier to calculate the address of an element in a 2D array.</p>
      </article>
      <article>
        <h5>1.3.2 Column-Major Order</h5>
        <p>In column-major order, the elements of a multi-dimensional array are stored in memory column by column. This means that the elements in the first column are stored first, followed by the elements in the second column, and so on. Some programming languages, like Fortran, use column-major order by default.</p>
        <p>For a two-dimensional array $A$ with $m$ rows and $n$ columns, the address of the element at row $i$ and column $j$ in column-major order can be calculated using the following formula:</p>
        <p>$$Address(A[i][j]) = BaseAddress(A) + ((j * m) + i) * sizeof(datatype)$$</p>
    </main>

    <script>copyright("all");</script>
  </body>

</html>