<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Producer Consumer problem - CSU360 - Shoolini U</title>
        <meta name="description" content="Producer Consumer problem - CSU360 - Shoolini U - dmj.one">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Practical 12: Write a C program to implement Producer Consumer problem using semaphores.
                </h2>

                <blockquote class="d-none d-print-flex mt-5 text-decoration-none" style="font-style:unset !important">
                    <p class="citation">
                        Mohan, D. (2024, April 22).
                        <em>C program to implement Producer Consumer problem using semaphores</em>.
                        Practical 12: Write a C program to implement Producer Consumer problem using semaphores - CSU360 - Shoolini University.
                        Retrieved from https://dmj.one/edu/su/course/csu360/lab/producer-consumer-problem
                    </p>
                </blockquote>
            </article>

            <article id="ProducerConsumerProblem">
                <h3>1. Introduction to the Producer-Consumer Problem</h3>
                <p>The Producer-Consumer problem is a classic synchronization issue within multi-processing where two processes, the producer and the consumer, share a common, fixed-size buffer. The producer's job is to generate data, put it into the buffer, and start again. At the same time, the consumer consumes the data from the buffer. The challenge is to make sure that the producer won't try to add data into the buffer if it's full and the consumer won't try to remove data from an empty buffer.</p>
            </article>

            <article>
                <h4>1.1 Understanding Semaphores</h4>
                <p>Semaphores are synchronization tools used to control access to a common resource by multiple processes in a concurrent system such as a multitasking operating system. A semaphore is simply a variable that is non-negative and shared between threads. This variable is used to solve the critical section problem and to achieve process synchronization in the inter-process communication process.</p>
            </article>

            <article>
                <h4>1.2 Implementing the Producer-Consumer Problem in C using Semaphores</h4>
                <p>This implementation of the Producer-Consumer problem uses POSIX semaphores. Semaphores are typically used for protecting resources that have multiple instances.</p>
                <p>Key components of the solution include:</p>
                <ul>
                    <li><strong>Sem_empty</strong>: A semaphore that counts the number of empty spots in the buffer.</li>
                    <li><strong>Sem_full</strong>: A semaphore that counts the number of full spots in the buffer.</li>
                    <li><strong>Mutex</strong>: A semaphore that protects the buffer access.</li>
                </ul>
            </article>

            <article>
                <h5>1.2.1 Producer Code</h5>
                <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;

#define MAX_ITEMS 10
#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;

sem_t empty;
sem_t full;
pthread_mutex_t mutex;

void *producer(void *pno)
{
    int item;
    for(int i = 0; i &lt; MAX_ITEMS; i++) {
        item = rand(); // Produce an item
        sem_wait(&amp;empty);
        pthread_mutex_lock(&amp;mutex);
        buffer[in] = item;
        printf("Producer %d: Insert Item %d at %d\n", *((int *)pno),buffer[in],in);
        in = (in+1)%BUFFER_SIZE;
        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;full);
    }
}
</code></pre>
            </article>

            <article>
                <h5>1.2.2 Consumer Code</h5>
                <pre><code class="language-c">
void *consumer(void *cno)
{   
    for(int i = 0; i &lt; MAX_ITEMS; i++) {
        sem_wait(&amp;full);
        pthread_mutex_lock(&amp;mutex);
        int item = buffer[out];
        printf("Consumer %d: Remove Item %d from %d\n", *((int *)cno), item, out);
        out = (out+1)%BUFFER_SIZE;
        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;empty);
    }
}
</code></pre>
            </article>

            <article>
                <h5>1.2.3 Main Function</h5>
                <pre><code class="language-c">
int main()
{
    pthread_t pro,con;
    pthread_mutex_init(&amp;mutex, NULL);
    sem_init(&amp;empty, 0, BUFFER_SIZE);
    sem_init(&amp;full, 0, 0);

    int a = 1;
    pthread_create(&amp;pro, NULL, (void *)producer, (void *)&amp;a);
    int b = 2;
    pthread_create(&amp;con, NULL, (void *)consumer, (void *)&amp;b);

    pthread_join(pro, NULL);
    pthread_join(con, NULL);

    pthread_mutex_destroy(&amp;mutex);
    sem_destroy(&amp;empty);
    sem_destroy(&amp;full);

    return 0;
}
</code></pre>
                <p>This C program will successfully implement the Producer-Consumer problem using semaphores on a Kali Linux system, showcasing how semaphores can be used to manage synchronization between threads safely.</p>
            </article>

            <article>
                <h4>1.3 Alternate Implementation of Producer Consumer problem in C</h4>
                <p>Below is an alternate implementation for the Producer Consumer problem in C.</p>
                <pre><code class="language-c">#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;time.h>
#include &lt;string.h>
#include &lt;unistd.h>
#include &lt;pthread.h>
#include &lt;semaphore.h>

/*
use the pthread flag with gcc to compile this code
~$ gcc -pthread producer_consumer.c -o producer_consumer
*/


pthread_t *producers;
pthread_t *consumers;

sem_t buf_mutex,empty_count,fill_count;

int *buf,buf_pos=-1,prod_count,con_count,buf_len;


int produce(pthread_t self){
	int i = 0;
	int p = 1 + rand()%40;
	while(!pthread_equal(*(producers+i),self) && i < prod_count){
		i++;
	}
	printf("Producer %d produced %d \n",i+1,p);
	return p;
}


void consume(int p,pthread_t self){
	int i = 0;
	while(!pthread_equal(*(consumers+i),self) && i < con_count){
		i++;
	}

	printf("Buffer:");
	for(i=0;i<=buf_pos;++i)
		printf("%d ",*(buf+i));
	printf("\nConsumer %d consumed %d \nCurrent buffer len: %d\n",i+1,p,buf_pos);
	
}


void* producer(void *args){

	while(1){
		int p = produce(pthread_self());
		sem_wait(&empty_count);
		sem_wait(&buf_mutex);
		++buf_pos;			// critical section
		*(buf + buf_pos) = p; 
		sem_post(&buf_mutex);
		sem_post(&fill_count);
		sleep(1 + rand()%3);
	}
	
	return NULL;
}


void* consumer(void *args){
	int c;
	while(1){
		sem_wait(&fill_count);
		sem_wait(&buf_mutex);
		c = *(buf+buf_pos);
		consume(c,pthread_self());
		--buf_pos;
		sem_post(&buf_mutex);
		sem_post(&empty_count);
		sleep(1+rand()%5);
	}

	return NULL;
}

int main(void){
	
	int i,err;

	srand(time(NULL));

	sem_init(&buf_mutex,0,1);
	sem_init(&fill_count,0,0);

	printf("Enter the number of Producers:");
	scanf("%d",&prod_count);
	producers = (pthread_t*) malloc(prod_count*sizeof(pthread_t));

	printf("Enter the number of Consumers:");
	scanf("%d",&con_count);
	consumers = (pthread_t*) malloc(con_count*sizeof(pthread_t));

	printf("Enter buffer capacity:");
	scanf("%d",&buf_len);
	buf = (int*) malloc(buf_len*sizeof(int));

	sem_init(&empty_count,0,buf_len);

	for(i=0;i&lt;prod_count;i++){
		err = pthread_create(producers+i,NULL,&producer,NULL);
		if(err != 0){
			printf("Error creating producer %d: %s\n",i+1,strerror(err));
		}else{
			printf("Successfully created producer %d\n",i+1);
		}
	}

	for(i=0;i&lt;con_count;i++){
		err = pthread_create(consumers+i,NULL,&consumer,NULL);
		if(err != 0){
			printf("Error creating consumer %d: %s\n",i+1,strerror(err));
		}else{
			printf("Successfully created consumer %d\n",i+1);
		}
	}

	for(i=0;i&lt;prod_count;i++){
		pthread_join(*(producers+i),NULL);
	}
	for(i=0;i&lt;con_count;i++){
		pthread_join(*(consumers+i),NULL);
	}


	return 0;
}</code></pre>
<div class="text-center">
    <img src="../img/p12/p12-img1.webp" class="img-fluid dynamicimg" alt="Producer Consumer Problem">
    <figcaption class="figure-caption">Figure: Producer Consumer Problem</figcaption>
</div>
            </article>

            <article id="image-section">
                <h3>Image Reference</h3>
                <div class="mt-3">
                    <div class="row text-center" id="gallery"></div>
                </div>
            
                <div class="modal fade" id="imageModal" tabindex="-1" aria-labelledby="imageModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-xl">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="modalTitle"></h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body text-center">
                                <img id="modalImage" class="img-fluid" src="" alt="">
                            </div>
                            <div class="modal-footer justify-content-between">
                                <button type="button" class="btn btn-secondary" id="previousButton">Back</button>
                                <button type="button" class="btn btn-danger" data-bs-dismiss="modal">Close</button>
                                <button type="button" class="btn btn-primary" id="nextButton">Next</button>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

        </main>

        <script> copyright("all"); </script>
    </body>
<script>
    var currentImageIndex = -1; // Initialize current image index

    // Array of objects for each step
    var steps = [
        { src: "../img/p12/p12-img1.webp", alt: "FCFS", caption: "Figure: Producer Consumer Problem" },        
    ];

    // Function to initialize gallery
    function initGallery() {
        var gallery = document.getElementById('gallery');
        steps.forEach(function (step, index) {
            var col = document.createElement('div');
            col.className = 'col-12 col-sm-6 col-md-4 col-lg-3 mb-4';
            col.innerHTML = `
                                                        <img src="${step.src}" class="img-fluid dynamicimg" alt="${step.alt}" data-bs-toggle="modal" data-bs-target="#imageModal" onclick="openModal('${step.src}', '${step.alt}')">
                                                        <figcaption class="figure-caption text-center">${step.caption}</figcaption>
                                                    `;
            gallery.appendChild(col);

            // Update onclick to pass the current index
            col.querySelector('img').onclick = function () {
                openModal(step.src, step.alt, index);
            };
        });

        updateImageSources(); // Call the function to update all images with the 'dynamicimg' class
    }

    // Function to open modal

    var currentImageIndex = -1; // Initialize current image index

    // ... Your steps array and initGallery function ...

    // Function to open modal and set the image and title
    function openModal(src, alt, index) {
        currentImageIndex = index; // Set the current image index

        var modalTitle = document.getElementById('modalTitle');
        var modalImage = document.getElementById('modalImage');

        modalTitle.textContent = alt; // Set modal title to alt text
        modalImage.src = src;
        modalImage.alt = alt;

        // Set up previous button functionality
        var previousButton = document.getElementById('previousButton');
        previousButton.style.display = currentImageIndex > 0 ? 'block' : 'none'; // Show if not the first image
        previousButton.onclick = function () {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                var prevStep = steps[currentImageIndex];
                openModal(prevStep.src, prevStep.caption, currentImageIndex);
            }
        };

        // Set up next button functionality
        var nextButton = document.getElementById('nextButton');
        nextButton.style.display = currentImageIndex < steps.length - 1 ? 'block' : 'none'; // Show if not the last image
        nextButton.onclick = function () {
            if (currentImageIndex < steps.length - 1) {
                currentImageIndex++;
                var nextStep = steps[currentImageIndex];
                openModal(nextStep.src, nextStep.caption, currentImageIndex);
            }
        };
    }

    // Function to update image sources
    function updateImageSources() {
        let images = document.querySelectorAll(".dynamicimg");

        for (let image of images) {
            let imageName = image.src.split("/").pop();
            if (window.location.hostname === "dmj.one") {
                image.src = "https://cdn.dmj.one/edu/su/course/csu360/img/p12/" + imageName;
            } else {
                image.src = "../img/p12/" + imageName;
            }
        }
    }

    // Initialize gallery on document ready
    document.addEventListener('DOMContentLoaded', initGallery);
</script>

</html>