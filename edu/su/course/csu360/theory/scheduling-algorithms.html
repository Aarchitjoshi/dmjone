<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>OS Essentials - CSU360 - Shoolini University</title>
        <meta name="description" content="Unlock the power of OS with CSU360, covering introductory topics. Perfect for aspiring Operating System starters.">


        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Scheduling Algorithms
                </h2>
            </article>

            <article id="scheduling-algorithms">
                <h3>1. Scheduling Algorithms in Operating Systems</h3>
                <p>Scheduling algorithms are fundamental to the design of effective and efficient operating systems. They are strategies used by the operating system's scheduler to allocate processor time among various tasks. The choice of scheduling algorithm can significantly impact the performance and responsiveness of a system. This documentation delves into various scheduling algorithms, elucidating their mechanisms, benefits, and potential drawbacks.</p>
            </article>
            
            <article id="types-of-schedulers">
                <h3>2. Types of Schedulers</h3>
                <p>The operating system employs different types of schedulers to manage process scheduling: the long-term scheduler (or job scheduler), the short-term scheduler (or CPU scheduler), and the medium-term scheduler. The long-term scheduler regulates the admission of processes into the ready queue, essentially controlling the degree of multiprogramming. The short-term scheduler, on the other hand, decides which of the ready, in-memory processes are to be executed next by the CPU. The medium-term scheduler temporarily removes processes from the CPU to reduce the degree of multiprogramming, often used in swapping.</p>
            </article>
            
            <article id="criteria-for-scheduling">
                <h4>2.1 Criteria for Scheduling</h4>
                <p>Effective scheduling algorithms aim to optimize several criteria: CPU utilization, throughput, turnaround time, waiting time, and response time. CPU utilization seeks to keep the CPU as busy as possible, while throughput measures the number of processes that complete their execution per time unit. Turnaround time is the interval from the submission of a process to the completion of its execution. Waiting time is the sum of periods a process spends waiting in the ready queue, and response time is the time from the submission of a request until the first response is produced, not output (for time-sharing systems).</p>
            </article>
            
            <article id="scheduling-algorithms-explained">
                <h4>2.2 Scheduling Algorithms Explained</h4>
            </article>
            
            <article id="first-come-first-served">
                <h5>First-Come, First-Served (FCFS)</h5>
                <p>FCFS is the simplest type of CPU scheduling algorithm that schedules according to the order of arrival of the processes in the ready queue. It's non-preemptive, meaning once a process starts executing, it runs to completion. While FCFS is easy to implement and understand, it can lead to poor performance in terms of average waiting time, especially in the presence of processes with varying execution times (the convoy effect).</p>
            </article>
            
            <article id="shortest-job-first">
                <h5>Shortest Job First (SJF)</h5>
                <p>SJF is a scheduling policy that selects the process with the smallest execution time to run next. It can significantly reduce the average waiting time compared to FCFS and is both available in preemptive and non-preemptive forms. The main challenge of SJF is predicting the next CPU burst length, which might not be feasible in all scenarios. Despite its efficiency in reducing waiting time, SJF can lead to starvation, where longer processes may never get scheduled if shorter processes keep arriving.</p>
            </article>
            
            <article id="priority-scheduling">
                <h5>Priority Scheduling</h5>
                <p>Priority scheduling assigns each process a priority, and the CPU is allocated to the process with the highest priority (smallest integer ≡ highest priority). Priorities can be determined by various factors such as memory requirements, time constraints, or user preference. Priority scheduling can be preemptive or non-preemptive. While effective in meeting specific system goals, it can suffer from starvation, which can be mitigated through aging techniques.</p>
            </article>
            
            <article id="round-robin">
                <h5>Round Robin (RR)</h5>
                <p>RR is a preemptive variant of CPU scheduling that assigns a fixed time unit called a time quantum or time slice for each process in the ready queue. The processes are scheduled in a circular order, and if a process's execution is not completed within the allocated time quantum, it's placed at the end of the ready queue. RR reduces response time but can increase the average waiting time. The performance of RR significantly depends on the length of the time quantum.</p>
            </article>
            
            <article id="multilevel-queue-scheduling">
                <h5>Multilevel Queue Scheduling</h5>
                <p>Multilevel queue scheduling partitions the ready queue into several separate queues, each with its own scheduling algorithm. Processes are permanently assigned to a queue based on their characteristics, such as process priority, type, or memory requirements. This method allows for flexibility in treating different categories of processes differently but requires complex scheduling logic and may lead to starvation in lower-priority queues.</p>
            </article>
            
            <article id="multilevel-feedback-queue">
                <h5>Multilevel Feedback Queue Scheduling</h5>
                <p>This variant of multilevel queue scheduling allows processes to move between queues based on their behavior and requirements. It offers the flexibility to adjust the scheduling criteria over time, providing a balance between turnaround time and response time for various types of processes. The configuration of the queues (number, scheduling algorithms, time quantum) significantly influences the effectiveness of this approach.</p>
            </article>
            
            <article>
                <h4>Implementation Considerations</h4>
                <p>Implementing scheduling algorithms requires careful consideration of the system's goals and the characteristics of the processes it handles. While theoretical understanding is crucial, practical considerations such as the overhead of context switching, system load, and the predictability of process behavior play a significant role in the choice and customization of scheduling algorithms. Performance metrics and testing under various load conditions are essential to evaluate the effectiveness of a scheduling strategy.</p>
                <p>It is imperative to understand that no single scheduling algorithm is universally optimal. The choice depends on the specific requirements and constraints of the operating system environment.</p>
            </article>            
            
            <article id="key-terminologies">
                <h3>3. Key Terminologies</h3>
                <p>Understanding the following terms is crucial for grasping the concepts of scheduling algorithms:</p>
                <ul>
                    <li><strong>Burst Time</strong>: The time required by a process for its execution.</li>
                    <li><strong>Arrival Time</strong>: The time at which a process arrives in the scheduling queue.</li>
                    <li><strong>Waiting Time (WT)</strong>: The total time a process has been waiting in the queue before its execution.</li>
                    <li><strong>Turnaround Time (TAT)</strong>: The total time taken by a process from getting to the queue to its completion.</li>
                    <li><strong>Response Time</strong>: The time from the arrival of a process to the first time it is scheduled.</li>
                </ul>
            </article>
            
            <article id="formulas-for-calculation">
                <h3>4. Formulas for Calculation</h3>
                <p>Key formulas used in scheduling algorithms include:</p>
                <article>
                    <h4>4.1 Waiting Time (WT)</h4>
                    <p>For FCFS, WT can be calculated iteratively, with the first process having a waiting time of 0. $$WT = WT_{previous} + BT_{previous} - AT$$</p>
                </article>
                <article>
                    <h4>4.2 Turnaround Time (TAT)</h4>
                    <p>$$TAT = BT + WT$$ It is the sum of burst time and waiting time for a process.</p>
                </article>
                <article>
                    <h4>4.3 Average Waiting Time (AWT)</h4>
                    <p>$$AWT = \frac{\sum_{i=1}^{n} WT_i}{n}$$ Where \(n\) is the number of processes.</p>
                </article>
                <article>
                    <h4>4.4 Average Turnaround Time (ATAT)</h4>
                    <p>$$ATAT = \frac{\sum_{i=1}^{n} TAT_i}{n}$$ This is the average of turnaround times for all processes.</p>
                </article>
            </article>
            
            <article id="scheduling-algorithms-and-their-formulas">
                <h3>5. Scheduling Algorithms and Their Formulas</h3>
                <article>
                    <h4>5.1 First-Come, First-Served (FCFS)</h4>
                    <p>Simplest scheduling algorithm that schedules according to arrival times of processes. The calculation of WT and TAT are straightforward as processes are executed in the order they arrive without preemption.</p>
                </article>
                <article>
                    <h4>5.2 Shortest Job First (SJF)</h4>
                    <p>SJF schedules processes based on the shortest burst time. This requires knowledge of the future, making it ideal for batch processing. It can significantly reduce average waiting and turnaround time but may lead to starvation of longer processes.</p>
                </article>
                <article>
                    <h4>5.3 Priority Scheduling</h4>
                    <p>Processes are scheduled based on priority. External factors can determine priority, and processes with the same priority are scheduled FCFS. The challenge lies in defining priorities to avoid starvation and ensure fairness.</p>
                </article>
                <article>
                    <h4>5.4 Round Robin (RR)</h4>
                    <p>Designed for time-sharing systems, it assigns a time quantum; processes are executed for a quantum then moved to the back of the queue. WT and TAT depend on the length of the quantum. Proper quantum size is crucial for efficiency.</p>
                    <p>$$WT = \frac{total\,waiting\,time}{number\,of\,processes}$$</p>
                </article>
                <article>
                    <h4>5.5 Multilevel Queue Scheduling</h4>
                    <p>Divides the ready queue into several separate queues, each with its scheduling algorithm. Priorities are assigned to each queue. This method combines various algorithms to efficiently handle processes of different types.</p>
                </article>
            </article>


        </main>
        <script> copyright("all"); </script>
    </body>

</html>