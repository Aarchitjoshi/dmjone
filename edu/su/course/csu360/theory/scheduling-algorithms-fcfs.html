<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Scheduling Algorithms: FCFS - CSU360 - Shoolini University</title>
        <meta name="description" content="Unlock the FCFS with CSU360, covering introductory topics and its formulas. Perfect for developing concept of First Come First Serve algorithm.">


        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Scheduling Algorithms: First Come First Serve
                </h2>
            </article>

            <article id="fcfs-overview">
                <h3 class="fw-bold">FCFS: First Come, First Served</h3>
                <p>First Come, First Served (FCFS) is a scheduling algorithm used by operating systems to manage the execution of processes. It operates under the simplest logic: the first process to request the CPU is the first to receive it. This algorithm is most effective in systems where tasks are relatively similar in nature and execution time. However, its simplicity can lead to inefficiency in handling a mix of short and long processes.</p>
            </article>
            <article>
                <h4>Characteristics of FCFS</h4>
                <ul>
                    <li><strong>Non-preemptive</strong>: Once a process starts execution, it runs to completion without being interrupted by other processes.</li>
                    <li><strong>Fairness</strong>: Processes are served in the exact order of their arrival, ensuring a first-come, first-served basis.</li>
                    <li><strong>Simplicity</strong>: FCFS is easy to understand and implement, making it a fundamental concept in operating system design.</li>
                    <li><strong>Varying Wait Times</strong>: Processes may experience long wait times, especially if preceded by a CPU-intensive process.</li>
                </ul>
            </article>

            <article>
                <h4>Advantages and Disadvantages of FCFS</h4>
                <h5>Advantages</h5>
                <ul class="list-unstyled">
                    <li>Simple to understand and implement.</li>
                    <li>Ensures fairness among processes.</li>
                </ul>

                <h5>Disadvantages</h5>
                <ul class="list-unstyled">
                    <li>Can lead to inefficient utilization of CPU, known as the convoy effect.</li>
                    <li>Varying and potentially long waiting times for processes.</li>
                </ul>
                <h5>FCFS drawbacks</h5>
                <p>While FCFS is straightforward, its efficiency can significantly vary depending on the nature and mix of processes. For instance, the "convoy effect" can occur when a series of short processes are delayed by a preceding long process, leading to increased average waiting and turnaround times. Understanding these nuances is crucial for system designers to optimize process scheduling under specific workload conditions.</p>
            </article>

            <article>
                <h4>Contextual Applications of FCFS</h4>
                <p>Despite its simplicity, FCFS is less efficient for CPU scheduling in multi-programming environments. However, it is effectively used in scenarios requiring simple queue management, such as print spooling and task scheduling in environments where tasks are non-interactive and execution time is relatively predictable.</p>
            </article>

            <article id="fcfs-terminologies">
                <h3 class="fw-bold">FCFS Terminologies and their Mathematical Analysis</h3>
                <ul class="list-unstyled">
                    <li><strong>Arrival Time (AT)</strong>: The time at which a process arrives in the queue.</li>
                    <li><strong>Burst Time (BT)</strong>: The total time a process requires the CPU for execution.</li>
                    <li><strong>Completion Time (CT)</strong>: The time at which a process completes its execution. It is calculated based on the burst time of the preceding process and the arrival time of the current process. If a process arrives and finds the CPU free, it starts execution. If the CPU is busy, the process waits until the CPU is free again.</li>
                    <li><strong>Turnaround Time (TAT)</strong>: $TAT = CT - AT$. This measures the total time taken for a process to be executed, including the waiting time in the queue and the actual execution time i.e. from getting to the queue to its completion.</li>
                    <li><strong>Waiting Time (WT)</strong>: $WT = TAT - BT$. This reflects the total time a process spends waiting in the queue to be executed.</li>
                    <li><strong>Average Turnaround Time (TAT<sub>ave</sub>)</strong>: $TAT_{ave} = \frac{\sum{TAT}}{n}$ where \(n\) is the number of processes. It is the average of turnaround times for all processes. </li>
                    <li><strong>Average Waiting Time (WT<sub>ave</sub>)</strong>: $WT_{ave} = \frac{\sum{WT}}{n}$, providing the average of waiting times for all processes thus giving overall waiting time efficiency across all processes.</li>
                </ul>
            </article>

            <article id="fsfsimpl">
                <h4>Implementation of FCFS</h4>
                <p>Implementing FCFS requires a queue structure to hold processes as they arrive. The scheduler selects the first process from the queue, executes it until completion, and then removes it from the queue to proceed with the next process.</p>
                <h5>Queue Data Structure</h5>
                <p>The queue is a fundamental data structure for FCFS, enabling FIFO (First In, First Out) management of processes. It supports operations such as enqueue (to add processes) and dequeue (to remove processes for execution).</p>
                <h5>Algorithm Steps</h5>
                <ol>
                    <li><strong>Enqueue</strong>: Upon arrival, a process is placed at the end of the queue.</li>
                    <li><strong>Dequeue</strong>: The process at the front of the queue is selected for execution.</li>
                    <li><strong>Execute</strong>: The selected process is executed until completion.</li>
                    <li><strong>Repeat</strong>: Upon completion, the process is removed, and the scheduler selects the next process from the queue.</li>
                </ol>
            </article>

            <article id="fcfs-gantt-chart">
                <h3 class="fw-bold">Creating a Gantt Chart for FCFS Scheduling</h3>
                <p>
                    A Gantt chart is a visual representation of the schedule for processes, showing start and finish times against a linear timescale. It illustrates the flow of processes in the FCFS scheduling algorithm and helps in analyzing the efficiency of process execution. Here's how to create a Gantt chart based on a process table containing process ID, arrival time (AT), and burst time (BT).
                </p>
                <ol>
                    <li><strong>Sort Processes by Arrival Time:</strong> Arrange the processes in the order they arrive. If two processes have the same arrival time, they can be ordered by their process ID or any other secondary criterion.</li>
                    <li><strong>Determine Start and Finish Times:</strong> For each process, calculate its start time (equal to the finish time of the previous process or its arrival time, whichever is later) and its finish time (start time plus its burst time).</li>
                    <li><strong>Create the Timescale:</strong> Draw a horizontal line and mark the time units along it. This line will serve as the timescale for the Gantt chart.</li>
                    <li><strong>Plot Processes:</strong> For each process, draw a bar starting at its start time and ending at its finish time. Label each bar with the process ID. The length of the bar represents the burst time of the process.</li>
                    <li><strong>Indicate Idle Times:</strong> If there is a gap between the finish time of one process and the start time of the next, indicate this as idle time on the chart. Idle times show when the CPU is not processing any task.</li>
                </ol>
                <p>Below is a simplified example of how to represent this in a textual format, assuming a process table with processes P1, P2, and P3 with respective arrival times and burst times.</p>
                <pre><code class="language-markdown">Process Table:
| Process | Arrival Time | Burst Time |
|---------|--------------|------------|
| P1      | 0            | 3          |
| P2      | 2            | 4          |
| P3      | 4            | 2          |

Gantt Chart Representation:
Time    0    3    7    9
        |----|----|----|
Process | P1 | P2 | P3 |
</code></pre>
                <p>This Gantt chart shows that P1 starts execution at time 0 and runs for 3 units of time, followed by P2, which starts immediately after P1 finishes and runs for 4 units of time. P3 starts at time 7, immediately after P2 finishes. There are no idle times in this example, indicating efficient CPU utilization for this sequence of processes under FCFS scheduling.</p>
            </article>


            <article id="fcfs-example">
                <h3 class="fw-bold">FCFS Scheduling Example</h3>
                <p>Consider a process table with 5 processes to demonstrate FCFS scheduling, calculate key metrics, and illustrate a Gantt chart.</p>
                <table class="table table-responsive table-striped table-bordered">
                    <tr>
                        <th>Process</th>
                        <th>Arrival Time (AT)</th>
                        <th>Burst Time (BT)</th>
                    </tr>
                    <tr>
                        <td>P1</td>
                        <td>0</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>P2</td>
                        <td>1</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>P3</td>
                        <td>2</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>P4</td>
                        <td>3</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>P5</td>
                        <td>4</td>
                        <td>5</td>
                    </tr>
                </table>
                <article>
                    <h4>Gantt Chart Representation</h4>
                    <p>The Gantt chart for these processes, scheduled according to FCFS, is as follows:</p>
                    <pre><code class="language-markdown">Time    0    4    7    8   10   15
        |----|----|----|----|----|
Process | P1 | P2 | P3 | P4 | P5 |
</code></pre>
                </article>
                <article>
                    <h4 class="mt-4">Calculating FCFS Metrics</h4>
                    <p>Next, we'll calculate the Completion Time (CT), Turnaround Time (TAT), and Waiting Time (WT) for each process, followed by the average TAT and WT.</p>
                </article>
                <article>
                    <h5 class="mt-4">Completion Time (CT)</h5>
                    <p>To find the CT for each process:</p>
                    <ul class="list-unstyled">
                        <li>\(CT_{P1} = AT_{P1} + BT_{P1} = 0 + 4 = 4\)</li>
                        <li>\(CT_{P2} = CT_{P1} + BT_{P2} = 4 + 3 = 7\)</li>
                        <li>\(CT_{P3} = CT_{P2} + BT_{P3} = 7 + 1 = 8\)</li>
                        <li>\(CT_{P4} = CT_{P3} + BT_{P4} = 8 + 2 = 10\)</li>
                        <li>\(CT_{P5} = CT_{P4} + BT_{P5} = 10 + 5 = 15\)</li>
                    </ul>
                </article>
                <article>
                    <h5 class="mt-4">Turnaround Time (TAT)</h5>
                    <p>To find the TAT for each process (\(TAT = CT - AT\)):</p>
                    <ul class="list-unstyled">
                        <li>\(TAT_{P1} = CT_{P1} - AT_{P1} = 4 - 0 = 4\)</li>
                        <li>\(TAT_{P2} = CT_{P2} - AT_{P2} = 7 - 1 = 6\)</li>
                        <li>\(TAT_{P3} = CT_{P3} - AT_{P3} = 8 - 2 = 6\)</li>
                        <li>\(TAT_{P4} = CT_{P4} - AT_{P4} = 10 - 3 = 7\)</li>
                        <li>\(TAT_{P5} = CT_{P5} - AT_{P5} = 15 - 4 = 11\)</li>
                    </ul>
                </article>
                <article>
                    <h5 class="mt-4">Waiting Time (WT)</h5>
                    <p>To find the WT for each process (\(WT = TAT - BT\)):</p>
                    <ul class="list-unstyled">
                        <li>\(WT_{P1} = TAT_{P1} - BT_{P1} = 4 - 4 = 0\)</li>
                        <li>\(WT_{P2} = TAT_{P2} - BT_{P2} = 6 - 3 = 3\)</li>
                        <li>\(WT_{P3} = TAT_{P3} - BT_{P3} = 6 - 1 = 5\)</li>
                        <li>\(WT_{P4} = TAT_{P4} - BT_{P4} = 7 - 2 = 5\)</li>
                        <li>\(WT_{P5} = TAT_{P5} - BT_{P5} = 11 - 5 = 6\)</li>
                    </ul>
                </article>
                <article>
                    <h5>Average Turnaround Time (TAT<sub>ave</sub>)</h5>
                    <p>$$TAT_{ave} = \frac{\sum{TAT_i}}{n}$$ $$= \frac{4 + 6 + 6 + 7 + 11}{5}$$ $$= \frac{34}{5}$$ $$= 6.8$$</p>
                </article>
                <article>
                    <h5>Average Waiting Time (WT<sub>ave</sub>)</h5>
                    <p>$$WT_{ave} = \frac{\sum{WT_i}}{n}$$ $$= \frac{0 + 3 + 5 + 5 + 6}{5}$$ $$= \frac{19}{5}$$ $$= 3.8$$</p>
                </article>
            </article>

            <article id="fcfs-implementation">
                <h3 class="fw-bold">FCFS Implementation in Python</h3>
                <p>Implementing FCFS requires a queue to manage processes in the order they arrive. Processes are selected for execution based on their arrival times, with the earliest arriving process being selected first. This section outlines a basic implementation of the FCFS scheduling algorithm.</p>
                <pre><code class="language-python">
# Python pseudo-code for FCFS scheduling

def fcfs_schedule(processes):
    """
    FCFS scheduling algorithm.
    :param processes: List of tuples containing (process_id, arrival_time, burst_time)
    :return: None
    """
    # Sort processes by their arrival time
    processes.sort(key=lambda x: x[1])
    
    current_time = 0
    for process in processes:
        process_id, arrival_time, burst_time = process
        if current_time < arrival_time:
            current_time = arrival_time  # Wait for process to arrive
        start_time = current_time
        finish_time = start_time + burst_time
        current_time += burst_time  # Update current time
        tat = finish_time - arrival_time
        wt = tat - burst_time
        print(f"Process {process_id}, AT: {arrival_time}, BT: {burst_time}, CT: {finish_time}, TAT: {tat}, WT: {wt}")
</code></pre>
                <p>This example demonstrates the FCFS algorithm applied to a set of processes, showing the calculation of CT, TAT, and WT for each process based on its arrival and burst times.</p>
            </article>

            <article id="fcfs-example">
                <h3 class="fw-bold">FCFS Scheduling Example in Python</h3>
                <p>Consider the following process table for an FCFS scheduling scenario:</p>
                <table class="table table-responsive table-striped table-bordered">
                    <tr>
                        <th>Process ID</th>
                        <th>Arrival Time (AT)</th>
                        <th>Burst Time (BT)</th>
                    </tr>
                    <tr>
                        <td>P1</td>
                        <td>0</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>P2</td>
                        <td>1</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>P3</td>
                        <td>2</td>
                        <td>2</td>
                    </tr>
                </table>

                <article>
                    <h4>Creating the Gantt Chart</h4>
                    <p>Based on the calculated metrics, the Gantt chart for the processes P1, P2, and P3 can be visually represented. The chart illustrates the execution sequence and duration of each process.</p>
                    <pre><code class="language-markdown">Gantt Chart:
Time    0    4    7    9
        |----|----|----|
Process | P1 | P2 | P3 |
</code></pre>
                    <p>This chart indicates that P1 starts execution at time 0 and continues for 4 units of time, followed by P2 starting at time 4 until time 7, and finally, P3 from time 7 to 9. The Gantt chart visually represents the scheduling of processes in an FCFS manner, highlighting the start and end times of each process without any idle times between them.</p>
                </article>

                <article>
                    <h4>Calculating CT, TAT, and WT</h4>
                    <pre><code class="language-python">
# Python code to calculate CT, TAT, WT for the given process table

def calculate_fcfs_metrics(processes):
    current_time = 0
    metrics = []
    for process in processes:
        pid, at, bt = process
        if current_time < at:
            current_time = at
        ct = current_time + bt
        tat = ct - at
        wt = tat - bt
        metrics.append((pid, ct, tat, wt))
        current_time = ct
    return metrics

# Define the processes
processes = [("P1", 0, 4), ("P2", 1, 3), ("P3", 2, 2)]

# Calculate metrics
metrics = calculate_fcfs_metrics(processes)

# Output the results
for metric in metrics:
    print(f"Process {metric[0]}, CT: {metric[1]}, TAT: {metric[2]}, WT: {metric[3]}")
</code></pre>
                    <p>This code calculates the Completion Time (CT), Turnaround Time (TAT), and Waiting Time (WT) for each process based on the FCFS scheduling algorithm. The results provide the necessary data to create a Gantt chart.</p>
                </article>


            </article>


        </main>
        <script> copyright("all"); </script>
    </body>

</html>