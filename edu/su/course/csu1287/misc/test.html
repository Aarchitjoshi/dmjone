<section class="pt-4">
    <h3 class="text-center">96. WAP in CPP to implement Linear Search.</h3>
    <div></div>
    <article class="syntax">
        <pre><code class="language-cpp">
#include &lt;iostream&gt;
using namespace std;

int linearSearch(int arr[], int n, int x) {
    for (int i = 0; i < n; i++)
        if (arr[i] == x)
            return i;
    return -1;
}

int main() {
    int n;
    cout << "Enter the number of elements: ";
    cin >> n;
    int arr[n];
    cout << "Enter the elements of the array: ";
    for(int i=0; i < n; i++)
        cin >> arr[i];
    int x;
    cout << "Enter the number to search: ";
    cin >> x;
    int result = linearSearch(arr, n, x);
    (result == -1) ? cout << "Element is not present in array"
                   : cout << "Element is present at index "  << result;
    return 0;
}
    </code></pre>
    </article>
    <article>
        <h3>Output:</h3><samp class="codeoutput text-justify">
            &emsp;
            Enter the number of elements: 5<br>
            Enter the elements of the array: 10 20 30 40 50<br>
            Enter the number to search: 30<br>
            Element is present at index 2</samp>
    </article>
</section>

<section class="pt-4">
    <h3 class="text-center">97. WAP in CPP to implement Depth First Search (DFS) on a graph.</h3>
    <div></div>
    <article class="syntax">
        <pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

class Graph {
    int V;
    list&lt;int&gt; *adj;
public:
    Graph(int V);
    void addEdge(int v, int w);
    void DFS(int v);
};

Graph::Graph(int V) {
    this->V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w) {
    adj[v].push_back(w);
}

void Graph::DFS(int v) {
    bool *visited = new bool[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;

    list&lt;int&gt; stack;
    visited[v] = true;
    stack.push_back(v);

    while(!stack.empty()) {
        v = stack.back();
        cout << v << " ";
        stack.pop_back();
        list&lt;int&gt;::iterator i;
        for(i = adj[v].begin(); i != adj[v].end(); ++i) {
            if (!visited[*i]) {
                stack.push_back(*i);
                visited[*i] = true;
            }
        }
    }
}

int main() {
    int nodes, edges, x, y, start;
    cout << "Enter number of nodes: ";
    cin >> nodes;
    Graph g(nodes);
    cout << "Enter number of edges: ";
    cin >> edges;
    for(int i=0; i < edges; i++) {
        cout << "Enter edge (Format: x y): ";
        cin >> x >> y;
        g.addEdge(x, y);
    }
    cout << "Enter initial node to traverse from: ";
    cin >> start;
    cout << "DFS traversal starting from node " << start << ": ";
    g.DFS(start);
    return 0;
}</code></pre></article>
    <article>
    <h3>Output:</h3><samp class="codeoutput text-justify">
&emsp;   
Enter number of nodes: 4<br>
Enter number of edges: 6<br>
Enter edge (Format: x y): 0 1<br>
Enter edge (Format: x y): 0 2<br>
Enter edge (Format: x y): 1 2<br>
Enter edge (Format: x y): 2 0<br>
Enter edge (Format: x y): 2 3<br>
Enter edge (Format: x y): 3 3<br>
Enter initial node to traverse from: 2<br>
DFS traversal starting from node 2: 2 3 0 1 </samp></article>
</section>

<section class="pt-4">
    <h3 class="text-center">98. WAP in CPP to implement Breadth First Search (BFS) on a graph.</h3> 
    <div></div>
    <article class="syntax">
    <pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

class Graph {
    int V; 
    list&lt;int&gt; *adj;   
public:
    Graph(int V); 
    void addEdge(int v, int w);
    void BFS(int s); 
};

Graph::Graph(int V) {
    this->V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w) {
    adj[v].push_back(w); 
}

void Graph::BFS(int s) {
    bool *visited = new bool[V];
    for(int i = 0; i < V; i++)
        visited[i] = false;

    list&lt;int&gt; queue;
    visited[s] = true;
    queue.push_back(s);

    list&lt;int&gt;::iterator i;

    while(!queue.empty()) {
        s = queue.front();
        cout << s << " ";
        queue.pop_front();

        for (i = adj[s].begin(); i != adj[s].end(); ++i) {
            if (!visited[*i]) {
                queue.push_back(*i);
                visited[*i] = true;
            }
        }
    }
}

int main() {
    int nodes, edges, x, y, start;
    cout << "Enter number of nodes: ";
    cin >> nodes;
    Graph g(nodes);
    cout << "Enter number of edges: ";
    cin >> edges;
    for(int i=0; i < edges; i++) {
        cout << "Enter edge (Format: x y): ";
        cin >> x >> y;
        g.addEdge(x, y);
    }
    cout << "Enter initial node to traverse from: ";
    cin >> start;
    cout << "BFS traversal starting from node " << start << ": ";
    g.BFS(start);
    return 0;
}
    </code></pre>
    </article>
    <article>
        <h3>Output:</h3><samp class="codeoutput text-justify">
            &emsp;
            Enter number of nodes: 4<br>
            Enter number of edges: 6<br>
            Enter edge (Format: x y): 0 1<br>
            Enter edge (Format: x y): 0 2<br>
            Enter edge (Format: x y): 1 2<br>
            Enter edge (Format: x y): 2 0<br>
            Enter edge (Format: x y): 2 3<br>
            Enter edge (Format: x y): 3 3<br>
            Enter initial node to traverse from: 2<br>
            BFS traversal starting from node 2: 2 0 3 1 </samp>
    </article>
</section>

<section class="pt-4">
    <h3 class="text-center">99. WAP in CPP to implement a Binary Search Tree (BST).</h3>
    <div></div>
    <article class="syntax">
        <pre><code class="language-cpp">
#include &lt;iostream&gt;
using namespace std;

struct Node {
    int key;
    struct Node *left, *right;
};

struct Node *newNode(int item) {
    struct Node *temp = new Node;
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}

void inorder(struct Node *root) {
    if (root != NULL) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}

struct Node* insert(struct Node* Node, int key) {
    if (Node == NULL) return newNode(key);

    if (key < Node->key)
        Node->left = insert(Node->left, key);
    else
        Node->right = insert(Node->right, key);

    return Node;
}

int main() {
    struct Node *root = NULL;
    int n, val;
    cout << "Enter the number of nodes: ";
    cin >> n;
    for(int i=0; i < n; i++) {
        cout << "Enter the value for node " << i+1 << ": ";
        cin >> val;
        if(i == 0) {
            root = insert(root, val);
        } else {
            insert(root, val);
        }
    }
    cout << "Inorder traversal of the BST: ";
    inorder(root);
    return 0;
}</code></pre>
    </article>
    <article>
        <h3>Output:</h3><samp class="codeoutput text-justify">
            &emsp;
            Enter the number of nodes: 5<br>
            Enter the value for node 1: 50<br>
            Enter the value for node 2: 30<br>
            Enter the value for node 3: 20<br>
            Enter the value for node 4: 40<br>
            Enter the value for node 5: 70<br>
            Inorder traversal of the BST: 20 30 40 50 70</samp>
    </article>
</section>

<section class="pt-4">
    <h3 class="text-center">100. WAP in CPP to implement Dijkstra's algorithm.</h3>
    <div></div>
    <article class="syntax">
        <pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;limits.h&gt;
#define V 9
using namespace std;

int minDistance(int dist[], bool sptSet[]) {
    int min = INT_MAX, min_index;
    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;
    return min_index;
}

void printSolution(int dist[]) {
    cout << "Vertex \t\t Distance from Source\n";
    for (int i = 0; i < V; i++)
        cout << i << " \t\t " << dist[i] << "\n";
}

void dijkstra(int graph[V][V], int src) {
    int dist[V];
    bool sptSet[V];
    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;
    for (int count

 = 0; count < V-1; count++) {
        int u = minDistance(dist, sptSet);
        sptSet[u] = true;

        for (int v = 0; v < V; v++)
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX
                && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }
    printSolution(dist);
}

int main() {
    int graph[V][V] = {
        {0, 4, 0, 0, 0, 0, 0, 8, 0},
        {4, 0, 8, 0, 0, 0, 0, 11, 0},
        {0, 8, 0, 7, 0, 4, 0, 0, 2},
        {0, 0, 7, 0, 9, 14, 0, 0, 0},
        {0, 0, 0, 9, 0, 10, 0, 0, 0},
        {0, 0, 4, 14, 10, 0, 2, 0, 0},
        {0, 0, 0, 0, 0, 2, 0, 1, 6},
        {8, 11, 0, 0, 0, 0, 1, 0, 7},
        {0, 0, 2, 0, 0, 0, 6, 7, 0}
    };
    dijkstra(graph, 0);
    return 0;
}
    </code></pre>
    </article>
    <article>
        <h3>Output:</h3><samp class="codeoutput text-justify">
            &emsp;
            Vertex Distance from Source<br>
            0 0<br>
            1 4<br>
            2 12<br>
            3 19<br>
            4 21<br>
            5 11<br>
            6 9<br>
            7 8<br>
            8 14<br></samp>
    </article>
</section>