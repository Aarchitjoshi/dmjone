<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>procedure vs Object Oriented Programming - CSU1287P - CSE 2026 - Shoolini University</title>
        <meta name="description" content="Procedure and Object Oriented Programming Language.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

    </head>

    <body>

        <script>header_author("dm");</script>

        <main>
            <article>
                <h2 class="text-center">
                    Procedure and Object Oriented Programming Language with example.
                </h2>
            </article>
            <article>
                <h3>Object-Oriented Programming</h3>
                <p>Object-Oriented Programming (OOP) is a programming paradigm that focuses on modeling real-world objects and their interactions. In OOP, objects are created from classes, which define their properties and behavior. These objects can interact with each other through methods and can inherit properties and behavior from other classes through inheritance. OOP also emphasizes encapsulation, which means that the internal state of an object is hidden from the outside world and can only be accessed through its methods. OOP is often used in larger software systems, where modularity, maintainability, and scalability are important.</p>
            </article>
            <article>
                <h4>Example of Object Oriented Programming</h4>
                <p>In the Object-Oriented Programming example in C++, a Rectangle class is defined, which encapsulates the length and width of a rectangle and defines a method for calculating its area. An instance of the Rectangle class is then created, and the <code>getArea()</code> method is called on that instance to calculate the area of the rectangle.</p>
            </article>
            <article class="syntax">
                <pre><code class="language-cpp">
#include &lt;iostream&gt;

// Rectangle class
class Rectangle {
private:
    int length;
    int width;
public:
    Rectangle(int l, int w) {
        length = l;
        width = w;
    }
    int getArea() {
        return length * width;
    }
};

// Main program
int main() {
    Rectangle rectangle(5, 10);
    int area = rectangle.getArea();
    std::cout << "Area of rectangle: " << area << std::endl;
    return 0;
}</code></pre>
            </article>

            <article>
                <h3>Procedure-Oriented Programming</h3>
                <p>
                    Procedure-Oriented Programming (POP) is a programming paradigm that focuses on the step-by-step execution of a program, where a sequence of instructions is followed to achieve a specific task. POP does not involve objects or classes, but instead uses functions or procedures to manipulate data. These functions take input parameters and produce output, and they can be called from other functions to perform more complex tasks. POP can be useful for smaller programs that do not require the complexity of OOP, and it is often used for scientific or mathematical applications, where data manipulation is the primary concern. However, POP can be more difficult to maintain and scale as the program grows in complexity.
                </p>
            </article>
            <article>
                <h4>Example of Procedure Oriented Programming</h4>
                <p>In the Procedure-Oriented Programming example in C, a function is defined to calculate the area of a rectangle, and the length and width are passed as parameters to that function. The <code>calculateRectangleArea()</code> function is then called in the main program to calculate the area of the rectangle.</p>
            </article>
            <article class="syntax">
                <pre><code class="language-c">
#include &lt;stdio.h&gt;

// Function to calculate the area of a rectangle
int calculateRectangleArea(int length, int width) {
    return length * width;
}

// Main program
int main() {
    int length = 5;
    int width = 10;
    int area = calculateRectangleArea(length, width);
    printf("Area of rectangle: %d\n", area);
    return 0;
}</code></pre>
            </article>

            <article>
                <h4>Key Aspects</h4>
                <p>Some of the key aspects of these methods of programming are:</p>
                <ul>
                    <li>
                        <strong>Method overloading</strong>: In Object-Oriented Programming, methods can have the same name but different parameters (method overloading), while in Procedure-Oriented Programming, this is not possible.
                    </li>
                    <li>
                        <strong>Data hiding</strong>: Object-Oriented Programming allows for data hiding, where data is kept private within an object and can only be accessed through its methods. In Procedure-Oriented Programming, all data is visible and can be accessed by any part of the program.
                    </li>
                    <li>
                        <strong>Code organization</strong>: Object-Oriented Programming encourages the organization of code into smaller, reusable modules, while Procedure-Oriented Programming often leads to larger, monolithic code bases.
                    </li>
                    <li>
                        <strong>Extensibility</strong>: Object-Oriented Programming is more extensible, as it allows for the creation of new classes that can inherit properties and methods from existing classes. In Procedure-Oriented Programming, modifying existing code can be more difficult and time-consuming.
                    </li>
                    <li>
                        <strong>Code maintenance</strong>: Object-Oriented Programming is generally easier to maintain, as changes can be made to individual objects or classes without affecting the rest of the program. In Procedure-Oriented Programming, changes to one part of the code can have unintended consequences on other parts of the program.
                    </li>
                    <li>
                        <strong>Parallel processing</strong>: Object-Oriented Programming can be better suited for parallel processing, as objects can be designed to work independently of each other. In Procedure-Oriented Programming, coordinating parallel processing can be more challenging.
                    </li>
                    <li>
                        <strong>Encapsulation</strong>: Object-Oriented Programming emphasizes encapsulation, where data and behavior are grouped together in objects. In Procedure-Oriented Programming, data and behavior are often separated.
                    </li>
                    <li>
                        <strong>Code readability</strong>: Object-Oriented Programming code can be more readable, as it often follows a natural language structure that is easy to understand. Procedure-Oriented Programming code can be more difficult to read, as it can be more procedural in nature.
                    </li>
                    <li>
                        <strong>Collaboration</strong>: Object-Oriented Programming can make collaboration easier, as objects can be designed to interact with each other in a standardized way. In Procedure-Oriented Programming, collaboration can be more ad hoc and prone to miscommunication.
                    </li>
                    <li>
                        <strong>Maintenance costs</strong>: Object-Oriented Programming can result in higher upfront costs due to the design and implementation of classes and objects. However, over time, the maintenance costs of Object-Oriented Programming can be lower due to the modularity and extensibility of the code. In Procedure-Oriented Programming, maintenance costs can be higher due to the monolithic nature of the code base.
                    </li>
                </ul>
            </article>

            <article>
                <table class="table table-striped table-bordered table-hover">
                    <thead class="thead-dark">
                        <tr>
                            <th>Aspect</th>
                            <th>Procedure-Oriented Programming</th>
                            <th>Object-Oriented Programming</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Focus</td>
                            <td>Procedure execution</td>
                            <td>Object behavior and interactions</td>
                        </tr>
                        <tr>
                            <td>Data management</td>
                            <td>Manipulated by functions and passed as parameters</td>
                            <td>Encapsulated in objects and accessed via methods</td>
                        </tr>
                        <tr>
                            <td>Code structure</td>
                            <td>Sequence of instructions</td>
                            <td>Classes and objects</td>
                        </tr>
                        <tr>
                            <td>Abstraction</td>
                            <td>Limited use of abstraction</td>
                            <td>Extensive use of abstraction</td>
                        </tr>
                        <tr>
                            <td>Inheritance</td>
                            <td>Not supported</td>
                            <td>Supported</td>
                        </tr>
                        <tr>
                            <td>Polymorphism</td>
                            <td>Not supported</td>
                            <td>Supported</td>
                        </tr>
                        <tr>
                            <td>Code reuse</td>
                            <td>Limited code reuse</td>
                            <td>Encouraged code reuse</td>
                        </tr>
                        <tr>
                            <td>Scalability</td>
                            <td>Difficult to scale</td>
                            <td>Easier to scale</td>
                        </tr>
                        <tr>
                            <td>Method overloading</td>
                            <td>Not supported</td>
                            <td>Supported</td>
                        </tr>
                        <tr>
                            <td>Data hiding</td>
                            <td>Not supported</td>
                            <td>Supported</td>
                        </tr>
                        <tr>
                            <td>Code organization</td>
                            <td>Monolithic</td>
                            <td>Modular</td>
                        </tr>
                        <tr>
                            <td>Extensibility</td>
                            <td>Difficult to extend</td>
                            <td>Easier to extend</td>
                        </tr>
                        <tr>
                            <td>Code maintenance</td>
                            <td>Can be more difficult and expensive over time</td>
                            <td>Can be easier and less expensive over time</td>
                        </tr>
                        <tr>
                            <td>Parallel processing</td>
                            <td>Can be challenging</td>
                            <td>Suited for parallel processing</td>
                        </tr>
                        <tr>
                            <td>Encapsulation</td>
                            <td>Not emphasized</td>
                            <td>Emphasized</td>
                        </tr>
                        <tr>
                            <td>Code readability</td>
                            <td>Can be less readable</td>
                            <td>Can be more readable</td>
                        </tr>
                        <tr>
                            <td>Collaboration</td>
                            <td>Ad hoc</td>
                            <td>Standardized</td>
                        </tr>
                    </tbody>
                </table>
            </article>
        </main>

        <script>copyright("all");</script>
    </body>

</html>