<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Frequently Asked Questions in C++ - CSU1287P - CSE 2026 - Shoolini University</title>
    <meta name="description" content="Know more about faq's in C++. Tailored for the level from basic to computer science students.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Frequently Asked Questions in C++
        </h2>

        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#summary"><i class="fas fa-chevron-circle-right"></i> Executive Summary</a> - Low on Time? Get the most important concepts within seconds.</li>
                    <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#details"><i class="fas fa-chevron-circle-right"></i> Understanding Virtual Functions</a></li>
                    <li class="p-1"><a href="#virtual-functions-usecases"><i class="fas fa-chevron-circle-right"></i> Benefits of Virtual Function and Operator Overloading</a></li>
                    <li class="p-1"><a href="#conclusion"><i class="fas fa-chevron-circle-right"></i> Conclusion</a></li>
                    </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>

      <article>
        <h3>Virtual Function</h3>
        <p>A virtual function, declared with the keyword 'virtual' in a base class, is designed for redefinition in derived classes. This mechanism supports runtime polymorphism in C++, allowing interchangeability of base and derived class objects, ensuring the correct function call.</p>
        <p>Let us learn about it with an example:</p>
        <pre><code>#include &lt;iostream>
using namespace std;

class Base {
public:
    virtual void print() {
        cout << "This is the base class print function.\n";
    }
};

class Derived : public Base {
public:
    void print() {
        cout << "This is the derived class print function.\n";
    }
};

int main() {
    Base baseObject;
    Derived derivedObject;

    baseObject.print();    // Calls Base::print()
    derivedObject.print(); // Calls Derived::print(), thanks to 'virtual' keyword

    return 0;
}</code></pre>
      </article>

      <article>
        <h3>Early Binding and Late Binding</h3>
        <p>
          Early Binding (or Static Binding) and Late Binding (or Dynamic Binding) refer to when the association of a function call to a function body is made.
        </p>
        <p>
          Early Binding happens at compile-time. The association of a function to its function call is made before the program runs. On the other hand, Late Binding occurs at runtime, where the compiler determines the type of an object at runtime and then binds the function call to its definition.
        </p>
        <pre><code>#include &lt;iostream>
using namespace std;

class Shape {
public:
    void draw() { //early binding
        cout << "Drawing a shape.\n";
    }
};

class Circle: public Shape {
public:
    void draw() { //late binding (using function overriding)
        cout << "Drawing a circle.\n";
    }
};

int main() {
    Shape shape;
    Circle circle;
    
    shape.draw(); // Outputs: Drawing a shape. (Early binding)
    circle.draw(); // Outputs: Drawing a circle. (Late binding)
    return 0;
}</code></pre>
        <p>Here, when you call draw() on shape, it knows at compile time it's going to call Shape::draw(). That's Early Binding. When you call draw() on circle, because draw() is a virtual function and circle is an instance of the derived class Circle, it doesn't decide until runtime which draw() it will call. This is Late Binding.</p>
      </article>

      <article>
        <h3>Operator Overloading</h3>
        <p>
          Operator Overloading is a compile-time polymorphism concept that allows you to redefine the way an operator works for user-defined types such as classes and structures. You can redefine or overload most of the built-in operators available in C++.
        </p>
        <pre><code>#include &lt;iostream>

class Counter {
    int count = 0;

public:
    void operator++() {
        count++;
    }

    int getCount() const {
        return count;
    }
};

int main() {
    Counter c;
    ++c;
    std::cout << c.getCount() << std::endl;
    return 0;
}</code></pre>
        <p>This code demonstrates a simple counter using operator overloading in C++. It defines a class called Counter with a private member variable count initialized to 0. The class overloads the pre-increment operator (++) to increment the count by 1.
        </p>
        <p>
          In the main function, an instance of the Counter class is created, and the overloaded ++ operator is used to increment the count. The current count value is then printed using the getCount member function.
        </p>
        <p>
          The code showcases how operator overloading can be used to redefine the behavior of operators, providing custom functionality for user-defined types. In this case, it allows the Counter object to be incremented in a natural and intuitive way.</p>
      </article>


      <article>
        <h3>Friend Function</h3>
        <p>A friend function in C++ is a function that has the right to access all private and protected members (variables and functions) of the class, even though it is not itself a member function of that class. This helps enhance the flexibility of the code where certain functions require direct access to class members.
          <br>Here's a simple example of using a friend function to add two numbers:
        </p>
        <pre><code>#include &lt;iostream>
using namespace std;

class Number {
    int num;
public:
    Number(int n) : num(n) {}

    // Declaration of friend function
    friend int addFive(Number n);
};

// Definition of friend function
int addFive(Number n) {
    return n.num + 5;  // can access private member 'num' directly
}

int main() {
    Number n(7);
    cout << addFive(n);  // Outputs: 12
    return 0;
}</code></pre>
        <p>In this example, addFive() is a friend function to class Number. Even though addFive() isn't a member function of Number, it can directly access the private data member num. This enables addFive() to add 5 to the value of num.</p>
      </article>

      <article>
        <h3>Friend Class</h3>
        <p>A friend class in C++ is a class whose members have the right to access all private and protected members of another class. It enhances the flexibility of the code where certain classes need direct access to another class's members.
          <br>
          Here's a simple example to demonstrate a friend class:
        </p>
        <pre><code>#include<iostream>
using namespace std;

class ClassB; // Forward declaration

class ClassA {
private:
    int numA;

public:
    ClassA() : numA(123) {}

    friend class ClassB;  // ClassB is a friend class of ClassA
};

class ClassB {
public:
    void showA(ClassA& a) {
        // Since ClassB is a friend of ClassA, it can access private members of ClassA
        cout << "ClassA::numA: " << a.numA << endl;
    }
};

int main() {
    ClassA a;
    ClassB b;
    b.showA(a);  // Outputs: ClassA::numA: 123
    return 0;
}</code></pre>
        <p>In this code, ClassB is a friend of ClassA. This means that ClassB can access the private and protected members of ClassA. In the showA method of ClassB, it directly accesses the private data member numA of ClassA.</p>
      </article>

      <article>
        
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>