<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Inheritance in C++ - CSU1287P - CSE 2026 - Shoolini University</title>
    <meta name="description" content="Know more about inheritance in C++. Tailored for the level from basic to PhD students.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Inheritance in C++
        </h2>
      </article>
      <article>
        <h3>1. Introduction to Inheritance</h3>
        <p>Inheritance is one of the four fundamental principles of object-oriented programming (OOP), along with encapsulation, polymorphism, and abstraction. Inheritance enables the creation of new classes that inherit the properties and methods of existing classes, promoting code reuse and modularity. This allows developers to build on existing code, extending or modifying its functionality as needed, without having to rewrite or duplicate large portions of code.</p>
      </article>
      <article>
        <h3>2. Benefits of Inheritance</h3>
        <p>Some benefits of inheritance in C++ include:</p>
        <ul>
          <li><strong>Code Reuse:</strong> Inheritance promotes the reuse of code by enabling new classes to inherit the properties and methods of existing classes.</li>
          <li><strong>Modularity:</strong> By organizing code into classes and inheritance hierarchies, developers can create more modular and maintainable code.</li>
          <li><strong>Extensibility:</strong> Inheritance makes it easy to extend or modify existing code by creating new classes that inherit from existing ones, without having to modify the original classes.</li>
          <li><strong>Abstraction:</strong> Inheritance enables the creation of abstract base classes that define the interface for a set of derived classes, making it easier to reason about the code and manage complexity.</li>
        </ul>
      </article>
      <article>
        <h3>3. Implementing Inheritance in C++</h3>
        <p>In C++, inheritance is achieved through the use of classes and the colon (:) operator. In this section, we will discuss how to implement inheritance in C++ and explore various aspects of this principle.</p>
      </article>
      <article>
        <h4>3.1 Base and Derived Classes</h4>
        <p>Inheritance involves two types of classes: base classes and derived classes. The base class is the existing class from which the new class inherits its properties and methods. The derived class is the new class that inherits the properties and methods of the base class.</p>
        <p>Here's a simple example of a base class and a derived class in C++:</p>
        <pre><code class="language-cpp">class Shape {
public:
    void setPosition(int x, int y) {
        x_ = x;
        y_ = y;
    }

protected:
    int x_;
    int y_;
};

class Circle : public Shape {
public:
    void setRadius(int radius) {
        radius_ = radius;
    }

private:
    int radius_;
};</code></pre>
        <p>In this example, the 'Shape' class is the base class, and the 'Circle' class is the derived class. The 'Circle' class inherits the 'setPosition' method and the 'x_' and 'y_' data members from the 'Shape' class, and it adds its own 'setRadius' method and 'radius_' data member.</p>
      </article>
      <article>
        <h4>3.2 Access Specifiers and Inheritance</h4>
        <p>When inheriting from a base class, it is important to consider the access specifiers of the base class members. As a reminder, C++ provides three access specifiers:</p>
        <ul>
          <li><strong>public:</strong> Members declared as public are accessible from any part of the code.</li>
          <li><strong>private:</strong> Members declared as private are only accessible from within the class and its member functions. Private members are not accessible in derived classes.</li>
          <li><strong>protected:</strong> Members declared as protected are accessible from within the class, its subclasses, and their member functions. Protected members are accessible in derived classes.</li>
        </ul>
        <p>In the 'Shape' class example, the 'x_' and 'y_' data members are declared as protected, which means they can be accessed from the 'Circle' derived class. If they were declared as private, the 'Circle' class would not be able to access them directly.</p>

      </article>
      <article>
        <h4>3.3 Inheritance Types</h4>
        <p>In C++, there are three types of inheritance, depending on the access specifier used when inheriting from a base class:</p>
        <ul>
          <li><strong>Public Inheritance:</strong> When a class is derived publicly from a base class, the public members of the base class become public members of the derived class, and the protected members of the base class become protected members of the derived class.</li>
          <li><strong>Protected Inheritance:</strong> When a class is derived with protected inheritance, both the public and protected members of the base class become protected members of the derived class.</li>
          <li><strong>Private Inheritance:</strong> When a class is derived privately, both the public and protected members of the base class become private members of the derived class.</li>
        </ul>
        <p>Here's an example illustrating the different inheritance types:</p>
        <pre><code class="language-cpp">class A {
public:
    int public_var;
protected:
    int protected_var;
private:
    int private_var;
};

class B : public A {
    // 'public_var' is public
    // 'protected_var' is protected
    // 'private_var' is not accessible
};

class C : protected A {
    // 'public_var' is protected
    // 'protected_var' is protected
    // 'private_var' is not accessible
};

class D : private A {
    // 'public_var' is private
    // 'protected_var' is private
    // 'private_var' is not accessible
};</code></pre>
        <p>In most cases, public inheritance is the preferred choice, as it maintains the original access levels of the base class members. However, protected and private inheritance can be useful in specific situations where more restricted access is desired.</p>
      </article>
      <article>
        <h4>3.4 Constructors and Destructors in Inheritance</h4>
        <p>When a derived class object is created or destroyed, the constructors and destructors of the base class and derived class are called in a specific order:</p>
        <ul>
          <li><strong>Construction:</strong> When a derived class object is created, the base class constructor is called first, followed by the derived class constructor. If the derived class has multiple base classes, their constructors are called in the order they are declared in the derived class.</li>
          <li><strong>Destruction:</strong> When a derived class object is destroyed, the derived class destructor is called first, followed by the base class destructor.</li>
        </ul>
        <p>If the base class has a constructor with arguments, the derived class constructor must explicitly call the base class constructor and pass the appropriate arguments. Here's an example:</p>
        <pre><code class="language-cpp">class Base {
public:
    Base(int x) : x_(x) {}

private:
    int x_;
};

class Derived : public Base {
public:
    Derived(int x, int y) : Base(x), y_(y) {}

private:
    int y_;
};</code></pre>
        <p>In this example, the 'Derived' class constructor explicitly calls the 'Base' class constructor with the 'x' argument and initializes its own 'y_' data member.</p>
      </article>
      <article>
        <h3>4. Advanced Concepts in Inheritance</h3>
        <p>Inheritance in C++ can be further refined and enhanced through several advanced concepts, including:</p>
      </article>
      <article>
        <h4>4.1 Multiple Inheritance</h4>
        <p>Multiple inheritance is a feature in C++ that allows a class to inherit from more than one base class. This enables the derived class to inherit the properties and methods of multiple base classes. However, multiple inheritance can also introduce complexity and potential issues, such as the diamond problem, which we will discuss later in this section.</p>
        <p>Here's an example of multiple inheritance in C++:</p>
        <pre><code class="language-cpp">class A {
public:
    void methodA() {}
};

class B {
public:
    void methodB() {}
};

class C : public A, public B {
    // Inherits 'methodA' from class A
    // Inherits 'methodB' from class B
};</code></pre>
        <p>In this example, the 'C' class inherits from both the 'A' and 'B' classes, inheriting their 'methodA' and 'methodB' methods, respectively.</p>
      </article>
      <article>
        <h4>4.2 Virtual Base Classes and the Diamond Problem</h4>
        <p>The diamond problem occurs in multiple inheritance scenarios when a class inherits from two or more classes that share a common base class. This can lead to ambiguity and potential issues with the inheritance hierarchy.</p>
        <p>Consider the following example:</p>
        <pre><code class="language-cpp">class A {
public:
    void methodA() {}
};

class B : public A {
    // Inherits 'methodA' from class A
};

class C : public A {
    // Inherits 'methodA' from class A
};

class D : public B, public C {
    // Inherits 'methodA' from both class B and class C
};</code></pre>
        <p>In this example, the 'D' class inherits from both 'B' and 'C' classes, which in turn inherit from the 'A' class. This creates ambiguity regarding which 'methodA' implementation the 'D' class should inherit.</p>
        <p>To resolve the diamond problem, C++ provides the concept of virtual base classes. By using the 'virtual' keyword when inheriting a base class, you can ensure that only a single instance of the base class is included in the inheritance hierarchy.</p>
        <p>Here's the modified example using a virtual base class:</p>
        <pre><code class="language-cpp">class A {
public:
    void methodA() {}
};

class B : virtual public A {
    // Inherits 'methodA' from class A
};

class C : virtual public A {
    // Inherits 'methodA' from class A
};

class D : public B, public C {
    // Inherits a single 'methodA' from class A
};</code></pre>
        <p>Now, the 'D' class inherits a single 'methodA' implementation from the 'A' class, avoiding ambiguity and resolving the diamond problem.</p>
      </article>
      <article>
        <h4>4.3 Polymorphism and Virtual Functions</h4>
        <p>Polymorphism is another key principle of OOP that enables the same function to have different implementations in the base class and its derived classes. In C++, polymorphism is achieved using virtual functions, which are declared using the 'virtual' keyword.</p>
        <p>Here's an example of polymorphism using virtual functions:</p>
        <pre><code class="language-cpp">class Shape {
public:
    virtual void draw() {
        // Default implementation for drawing a shape
    }
};

class Circle : public Shape {
public:
    void draw() override {
        // Implementation for drawing a circle
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        // Implementation for drawing a rectangle
    }
};</code></pre>

        <p>In this example, the 'Shape' class defines a virtual 'draw' function, which provides a default implementation for drawing a shape. The 'Circle' and 'Rectangle' classes, derived from the 'Shape' class, override the 'draw' function to provide their own implementations for drawing a circle and a rectangle, respectively.</p>
        <p>When working with polymorphism, it is common to use pointers or references to base class objects to call the appropriate virtual function implementation. Here's an example of how to use polymorphism with virtual functions:</p>
        <pre><code class="language-cpp">Shape* shape1 = new Circle();
Shape* shape2 = new Rectangle();

shape1->draw(); // Calls the 'draw' function of the 'Circle' class
shape2->draw(); // Calls the 'draw' function of the 'Rectangle' class

delete shape1;
delete shape2;</code></pre>
        <p>In this example, we create pointers to 'Shape' objects that point to instances of the 'Circle' and 'Rectangle' classes. When calling the 'draw' function through these pointers, the appropriate implementation for each derived class is called, demonstrating polymorphism.</p>
      </article>
      <article>
        <h4>4.4 Abstract Base Classes</h4>
        <p>Abstract base classes are classes that define an interface for a set of derived classes but cannot be instantiated on their own. In C++, abstract base classes are created by declaring one or more virtual functions as pure virtual, using the '= 0' syntax.</p>
        <p>Here's an example of an abstract base class:</p>
        <pre><code class="language-cpp">class Shape {
public:
    virtual void draw() = 0; // Pure virtual function
};

class Circle : public Shape {
public:
    void draw() override {
        // Implementation for drawing a circle
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        // Implementation for drawing a rectangle
    }
};</code></pre>
        <p>In this example, the 'Shape' class is an abstract base class because it has a pure virtual 'draw' function. This means that it is not possible to create an instance of the 'Shape' class, and it can only be used as a base class for other classes, like the 'Circle' and 'Rectangle' classes in this example.</p>
      </article>
      <article>
        <h3>5. Conclusion</h3>
        <p>Inheritance is a powerful principle of object-oriented programming that promotes code reuse, modularity, and extensibility in C++. Through the use of base and derived classes, inheritance types, and advanced concepts such as multiple inheritance, virtual base classes, polymorphism, and abstract base classes, C++ provides a flexible and robust framework for building complex software systems.</p>
        <p>By understanding and applying the concepts discussed in this article, you can create more efficient, maintainable, and scalable code that is easier to understand and modify, making you a more effective C++ programmer, from the basics to the PhD level.</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>